 <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script type="text/javascript" src=""></script>
    <script type="xxx">
      console.log(2021);
      console.log(2021 * 2);
      console.log(2021 * 2021);
      console.log(2021 * 2021 * 2021 * 2021 * 2021);
      console.log(201 > 50 && 2021 > 100);
      console.log(2021 % 2 == 1);
      console.log(2021 % 2 == 0);
      console.log(2021 % 10);
      console.log(2021 % 100);
      console.log(2021 > 200 && 2021 % 3 && 2021 % 7 != 0);
      console.log((1864 - (1864 % 100)) / 100 + 1);
    </script>
    <script type="">
      // 控制浏览器弹出一个警告框
      alert("这是我的第一行js代码");
      // 输出在浏览器窗口

      // 让计算机在页面中输出一个内容
      // document(文档的意思，一个网页就是一个文档)

      document.write("写一个文档 看我出不出来");
      // 输出在在body 页面中

      // 向控制台输出一个内容
      console.log("你猜我在哪儿出来呢？");
      // 输出在控制台

      // js代码指令是从上到下一条一条执行的;
      alert("这是我的第一行代码");
      document.write("写一个文档 看我出不出来");
      console.log("你猜我在哪儿出来呢？");
      // 以上三个都是输出语句
    </script>
    <script type="字面量和变量">
      /*
        字面量 都是一些不可改变的值 例如:1 2 3 4 5 6
        字面量都是可以直接使用的,但是我们一半不会直接使用字面量

        *变量 可以保存我们的字面量 例如:x=1;
        而且变量的值是可以任意改变的，变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量
        变量还可以对字面量进行描述 例如 age=80;

        *声明变量
        在js中使用var关键字来声明一个变量 例如:var a;

        *为变量赋值
        a=123;

        *声明变量和赋值同时进行
        var age = 80;
        age = 81;(赋值后面的这个有效)
        console.log(age)
      */
    </script>
    <script type="标识符">
      /*
        *标识符
         在js中所以可以由我们自主命名的都叫标识符 例如:var a;这个a就是我们给它起的名字标识符
         变量名、函数名、属性名都属于标识符
         命名一个标识符时，需要遵守如下规则
           1.标识符中可以含有字母、数字、_、%、     例如: var s_1_$ = 123; console.log(s_1_$);
           2.标识符不能以数字开头
           3.标识符不能是JS中的关键字或保留字       例如:var var=123;
           4.标识符一般采用驼峰命名法
             首字母小写，后面每个单词的开头字母大写，其余字母小写 例如:helloWorld
         JS底层保存标识符时 实践上采用的是Unicode编码(UTF-8),所以理论上讲 所有的utf-8中所有的内容都可以作为标识符
      */
    </script>
    <script type="数据类型">
      /*
        *数据类型指的就是字面量的类型
        *在JS中一共有六种数据类型
          String 字符串
          Number 数值
          Boolean 布尔值
          Null 空值
          Undefined 未定义
          Object 对象
        *其中 String Number Boolean Null Undefined属于基本数据类型
          而Object属于引用数据类型
      */
      /*
        *String字符串
          在JS中字符串需要使用""引起来 var str="hello"; "hello"字符串赋值给了str这个变量 那么str它也是一个字符串
          使用单引号或双引号都可以，但是不要混着用
          引号不能嵌套 双引号里不能放双引号 同理，单引号里不能有单引号
          在字符串中我们可以使用\作为转义字符。 例如:\n表示换行。\t表示制表符，相当于按了个tab键。
      */
      /*
        *Number
          在JS中所有的数值都是Number类型，包括整数和浮点数(小数)

            var a = 123;
            var b = "123";

          JS中可以使用一个运算符 typeof 来检查一个变量的类型。语法:
            console.log(typeof a);表示检查a这个变量的类型并输出
            检查数值时，会返回Namber
            检查字符串时 会返回String

          JS中可以表示数字的最大值 Number.MAX_VALUE。语法:
            console.log(Number.MAX_VALUE);
            如果使用Number表示的数字超过了最大值，则会返回一个Infinity，表示正无穷。Infinity就是一个字面量，不需要加双引号。
              a = Infinity；
              console.log(typeof a);使用typeof检查Infinity也会返回Number

          JS中可以表示数字0以上的最小值 Number.MIN_VALUE。语法:
            console.log(Number.MIN_VALUE);
            大于0的最小正值

          NaN 是一个特殊的数字，表示Not a Namber
              a = NaN
              console.log(typeof a);使用typeof检查NaN也会返回number

          计算:
              var c = 123 + 456;
              console.log(c);
              把123+456的结果赋值给变量c
            在JS中整数的运算基本可以保证精确

              var c = 0.1 + 0.2;
            如果使用js进行浮点运算，可能得到的是一个不精确的结果,所以千万不要使用JS进行精确度要求比较高的运算。

        *Boolean布尔值
          布尔值只有两个，主要用来做逻辑判断
          true
            表示逻辑上的真
          false
            表示逻辑上的假
          var bool = true;
          console.log(bool);控制台显示为true
          console.log(typeof bool);使用typeof检查bool也会返回Boolean

        *Null空值
          Null的值只有一个，就是null
            null这个值专门来表示一个为空的对象
          var a = null;
          console.log(a);控制台显示为null
          console.log(typeof a);使用typeof检查null时会返回object，因为它专门来表示一个为空的对象

        *Undefined 未定义
          Undefined的值也是只有一个，就是undefined
            当我们声明一个变量，但不给变量赋值时，它的值就是undefined
          var b;
          console.log(b);控制台显示为undefined
          console.log(typeof b);使用typeof检查undefined时会返回undefined
      */
    </script>
    <script id="强制类型转换">
      /*
        *强制类型转换
          指的是讲一个数据类型强制转换为其他数据类型
            类型转换主要指，将其它类型转换为String Number Boolean

        *将其它数据类型转换为String
          方式一:
                调用被转换数据类型的toString()方法。
                该方法不会影响到源变量，它会将转换的结果返回
                但是注意：null和undefined这两个值没有toString()方法。如果调用它俩，会报错。
          方式二:
                调用String()函数，并将被转换的数据作为参数传递给函数
                使用String()函数做强制类型转换时，对于number和boolean实际上调用的就是toString()方法
                  但是对于null和undefined，就不会调用toString()方法。它会将字面量的null直接转换为字符号的"null",会将字面量的undefined直接转换为字符号的"undefined"


          var a = 123;
          console.log(typeof a); 输出类型为Number
          console.log(a);        输出值为123

          (1)调用a的toString方法:
            a = a.toString();    强制类型转换为String了
          (2)调用String()函数，来将A转换成字符串
            a = String(a)            转谁就把谁放到括号里，那括号里的a就叫参数。a作为参数传到我们的括号里，表示我们要把a转换成字符串。

        *将其它数据类型转换为Number
          方式一：
                使用Number()函数
                  字符串转数字
                    如果是纯数字的字符串，则直接转换成数字
                    如果字符串中有非数字的内容，则转换成NaN
                    如果字符串是个空串或者是全是空格的字符串""，则转成0
                  布尔转数字
                    true转成1
                    false转成0
                  null转数字 转成0
                  undefined转数字 转成NAN
          方式二：
                这种方式专门对付字符串
                parseInt() 把一个字符串转换成一个整数。
                parseFloat() 把一个字符串转换成一个浮点数。
                如果对非String使用parseInt()或parseFloat()，它会先将其转换成String再操作，有时可以利用这一点间接的对浮点数parseInt()取整

          var a = "123";
          console.log(typeof a); 输出类型为String
          console.log(a);        输出值为"123"

          (1)调用Number()函数，来将A转换成Number
            a = Number(a)

          var a = "123px";
          (2)调用parseInt()函数，把一个字符串转换成一个整数
            a = parseInt()    parseInt()可以将一个字符串中的有效的整数内容取出来，然后转换成Number
          var a = "123.456px";
          (2)调用parseFloat()函数，把一个字符串转换成一个浮点数。
            a = parseFloat()  parseFloat()可以将一个字符串中的有效的浮点数内容取出来，然后转换成Number

        *将其它数据类型转换为Boolean
          方式一：
                使用Boolean()函数
                  数字转布尔
                    除了0和NAN，其余的则都是直接转换成true
                  字符串转布尔
                    除了空串，其余的则都是直接转换成true
                  null和undefined转布尔
                    都会转换为false
                  对象转布尔
                    也会转换为true

          var a = 123;
          console.log(typeof a); 输出类型为Number
          console.log(a);        输出值为"123"

          (1)调用Boolean()函数，来讲a转为布尔值
            a = Boolean(a)       显示为true
      */
    </script>
    <script id="算数运算符">
      /*
        *运算符(也叫操作符)
          通过运算符可以对一个值或多个值进行运算，并获取运算结果
            例如:typeof就是一个运算符，可以获得一个值的类型
              它会讲该值的类型以字符串的形式返回
              number  string  boolean  undefined  object
            var a = 123
            var result = typeof a; 声明了result这个变量，result这个变量接收typeof这个运算符的运算结果
            console.log(result)
            console.log(typeof a)

        *算数运算符
          当对非number类型的值进行运算时，会将这些值转换为number，然后再运算.
            任何数和NaN做结果都是NaN

          + 可以对两个值进行加法进行运算，并将结果返回
              如果对两个字符串进行加法运算，则会做拼串。什么时拼串？(会将两个字符串拼接成一个字符串，并返回)
                result = "123" + "456"; 结果为123456
                result = "你好" + "大帅哥"; 结果为你好大帅哥
                result str = "锄禾日当午，" +
                             "汗滴禾下土，" +
                             "谁知盘中餐，" +
                             "粒粒皆辛苦";多字符串换行以后 后面添加+ 拼到一起成为一行里的四句
            任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
                result = 123 + "1"; 结果为1231
                result = true + "hello"; 结果为truehello
              我们可以利用这一点，来将任意类型的数据转换为String。只需要为任意的数据类型做+ ""即可将其转换为String
              这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数
                var c = 123
                c = c + ""
                console.log(c)
                控制台输出的结果是123，那它是谁的值呢我看不出来，所以我希望不仅输出的结果是123，还希望告诉我这个123是谁的值。所以我们经常采用这样一种写法
                console.log("c = "+c)


            result = true + 1; 结果为2
            result = true + false;  结果为1
            result = 2 + null; 结果为2
            result = 2 + NaN;
            result = 1 + 2 + "3"; 结果为33
            result = "3" + 1 + 2; 结果为312

          - 可以对两个值进行加法运算，并将结果返回
            result = 100 - "3"; 结果为97，和100 - 3是一样的。所以注意，只有字符串的+法这种特殊情况转String，其余的运算符对字符串进行运算时都是转成Number
          * 可以对两个值进行乘法运算
          / 可以对两个值进行除法运算
            任何值做 - * / 运算时都会转换成number
              我们可以利用这一特点做隐式的类型转换
                可以通过一个值 -0 *1 /1 来将其转换为number。原理和Number()函数一样，使用起来更加简单
                var d = "123"
                d = d - 0

          % 取模运算(取余数)
            result = 9 % 3; 9和3相除，取余数。9除3等于3，余数为0。结果为0
            result = 9 % 4; 9和4相除，取余数。9除4等于2，余数为1。结果为1
            result = 9 % 5; 9和5相除，取余数。9除5等于1，余数为4。结果为4
      */
    </script>
    <script id="一元运算符">
      /*
        *一元运算符,只需要一个操作数。(什么时操作数？1 + 1 就是两个操作数)
          +正号
            正号不会对数值产生影响
              var a = 123
              a = +a
              console.log("a = "+a) 控制台输出结果还是123
          -负号
            负号可以对数字进行符号的取反

            对于非number类型的值
              它会将会先转换为number,然后再运算
                a = true true转换成number为1
                a = -a   结果为-1
              可以对任意的的数据类型使用+ ，来将其转换为Number
              它的原理和number()函数一样
                a = "18"
                a = +a

                var result = 1 + "2" + 3        结果为字符串123
                console.log("result = "+result) 控制台结果为数值123

                var result = 1 + +"2" + 3       结果为数值6
                console.log("result = "+result)
      */
    </script>
    <script id="自增和自减 ">
      /*
        *自增
          通过自增可以使变量在自身的基础上增加1
            var a = 1
            a = a + 1;
            console.log(a) 控制台输出结果为2
          对于一个变量自增后，原变量的值会立即自增1
            var a = 1
            a++;//使a自身增1,后每调一次自身增1
            a++;
            a++;
            a++;
            console.log(a) 控制台输出结果为5
          自增分为两种:后++(a++) 前++(++a)
            无论是a++ 还是++a,都会立即使原变量a的值+1，这两种自增方式对于原变量a来说是没有任何区别的
            不同的是a++ 和 ++a的值不同
              a++的值等于原变量的值(自增前的值)
                var a = 1
                console.log(a++)       a++它是表达式的值 控制台结果为1
                console.log("a = "+a)  a它是变量的值     控制台结果为2
              ++a的值等于原变量自增后的值
                var a = 1
                console.log(++a)       控制台结果为2
                console.log("a = "+a)  控制台结果为2

              var c = 10
              c++                      第一次c++,是在10的基础上自增
              console.log(c++)         第二次c++,是在11的基础上自增，所以控制台结果为11

              var d = 20
              ++c                      ++d是新值，第一次自增是在20的基础上自增 自增后变成21
              console.log(++c)         第二次自增是在21的基础上自增，控制台结果为22

              var d = 20
              var resulst = d++ + ++d + d
                          //20 + 22 + 22
              console.log("resulst = "+resulst) 结果为64

        *自减
            通过自增可以使变量在自身的基础上减1
              var num = 10
              num--
              console.log("num = "+num)   控制台结果为9

              var num = 10
              --num
              console.log("num = "+num)   控制台结果为9
          自增分为两种:后--(a--) 前--(--a)
            不论是a--还是--a，都会立即使原变量的值自减1
            不同的是a-- 和 --a的值不同
              var num = 10
                a--的值等于原变量的值(自减前的值)
                  console.log(num--)        num--它是表达式的值 控制台结果为10
                  console.log("num = "+num) num它是变量的值     控制台结果为9
                --a的值等于原变量自减后的值
                  console.log(--num)        控制台结果为9
                  console.log("num = "+num) 控制台结果为9
      */
      /*
        *练习
        var n1 = 10, n2 = 20;
        var n = n1++;
        console.log("n = "+n);        10
        console.log("n = "+n1);       11
        n = ++n1
        console.log("n = "+n);        12
        console.log("n1 = "+n1);      12
        n = n2--
        console.log("n = "+n);        20
        console.log("n2 = "+n2);      19
        n = --n2
        console.log("n = "+n);        18
        console.log("n2 = "+n2)       18
      */
    </script>
    <script id="逻辑运算符">
      /*
        *JS中为我们提供了三种逻辑运算符
        * ! 非 可以用来对一个值进行非运算
            所谓非运算就是指对一个布尔值进行取反操作，true变false，false变true
              var a = true;
              a = !a
              console.log("a = "+a)    控制台结果为a=false

              var a = false;
              a = !a;
              console.log("a = "+a)    控制台结果为a=true
            如果对一个值进行两次取反，它不会变化，还是那个值
            如果对非布尔值进行运算，则会将其先转换成布尔值，然后取反
              var b = 10               对非布尔值取反先将非布尔值转换成Boolean true
              b = !b;                  再取反
              console.log("a = "+b)    控制台结果为false
            所以我们可以利用该特点，将一个任意的数据类型 取两次反，来将其转换成Boolean。原理和Boolean()函数一样。
              var b = 10               对非布尔值取反先将非布尔值转换成Boolean true
              b = !！b;                对一个值进行两次取反，它不会变化，还是那个值
              console.log("a = "+b)    控制台结果为true
        * && 与 可以对&&符号两侧的值进行与运算 并返回结果
            运算规则
            两个值中只要有一个值是false,就返回false.只有两个值都是true时，才会返回true
              只要有一个值都是false,就返回false
                var result = true && false
                console.log("result ="+result)  运算结果为result=false

              如果两个值都是true,则返回第二个true
                var result = true && true
                console.log("result ="+result)  运算结果为result=true

            JS中的"与"属于短路的与，如果第一个值为false，则不会看第二个值(因为我已经判断出结果了)
              第一个值为true，会检查第二个值
              true && alert("看我出不出来");     弹窗出来

              第一个值为false，不会检查第二个值
              false && alert("看我出不出来");    弹窗没有出来
        * || 或 可以对||符号两侧的值进行与运算 并返回结果
            运算规则
            两个值中只要有一个值是true,就返回true.只有两个值都是false时，才会返回false
              只要有一个值都是true,就返回true
                var result = false || true
                console.log("result ="+result)      运算结果为result=true
                var result = true || false
                console.log("result ="+result)      运算结果为result=true
                var result = true || true
                console.log("result ="+result)      运算结果为result=true

              如果两个值都是false,则返回false
                var result = false || false
                console.log("result ="+result)      运算结果为result=false
            JS中的"或"属于短路的或，如果第一个值为true，则不会看第二个值(因为我已经判断出结果了)
              第一个值为false，会检查第二个值
              false && alert("看我出不出来");        弹窗出来
              第一个值为true，不会检查第二个值
              true && alert("看我出不出来");         弹窗没有出来
      */
    </script>
    <script id="非布尔值的与或运算">
      /*
       *  && || 非布尔值的情况
            对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算,并且返回原值
            与运算
              如果第一个值为true,则必然返回第二个值
              如果第一个值为false,则直接返回第一个值

              与运算，如果两边都是true，则返回后面的
                var result = 1 && 2                  转换为布尔值true && true,那返回1还是返回2呢？
                console.log("result = "+result)      运算结果为2
                var result = 2 && 1                  转换为布尔值true && true,那返回1还是返回2呢？
                console.log("result = "+result)      运算结果为1

              与运算，只要有一个值都是false,就返回false
                var result = 0 && 2                  转换为布尔值false && true  与运算，只要有一个值都是false,就返回false
                console.log("result = "+result)      运算结果为0
                var result = 2 && 0                  转换为布尔值true && false
                console.log("result = "+result)      运算结果为0
              与运算，如果两边都是false，则返回前面的
                var result = NaN && 0                  转换为布尔值false && false,那返回哪个false呢？
                console.log("result = "+result)      运算结果为NaN
                var result = 0 && NaN                  转换为布尔值false && false,那返回哪个false呢？
                console.log("result = "+result)      运算结果为0
            或运算
              如果第一个值为true,则直接返回第一个值
                var result = 1 || 2                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为1
                var result = 2 || NaN                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为2

              如果第一个值为false,则直接返回第二个值
                var result = 0 || 2                  转换为布尔值false || true
                console.log("result = "+result)      运算结果为2
                var result = NaN || 0                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为0

                var result = "" || "hello"           转换为布尔值第一个空串为false
                console.log("result = "+result)      运算结果为hello
                var result = -1 || "hello"           转换为布尔值第一个值为true
                console.log("result = "+result)      运算结果为-1
      */
    </script>
    <script id="赋值运算符">
      /*
       * = 可以将符号右侧的值赋值给符号左侧的变量
          var a = 123
          console.log(a)            控制台结果为123

         += a += 5等价于a = a + 5
          var a = 10
          a = a + 5可以写成a += 5
          console.log("a = "+a)            控制台结果为a = 15

         -= a -= 5等价于a = a - 5
          var a = 10
          a = a - 5可以写成a -= 5
          console.log("a = "+a)            控制台结果为a = 5

         *= a *= 5等价于a = a * 5
          var a = 10
          a = a * 5可以写成a *= 5
          console.log("a = "+a)            控制台结果为a = 50

         /= a /= 5等价于a = a / 5
          var a = 10
          a = a / 5可以写成a /= 5
          console.log("a = "+a)            控制台结果为a = 2

         %= a %= 5等价于a = a % 5
          var a = 10
          a = a % 5可以写成a %= 5
          console.log("a = "+a)            控制台结果为a = 0
      */
    </script>
    <script id="关系运算符">
      /*
       *  通过关系运算符可以比较两个值之间的大小关系
            如果关系成立会返回true,如果关系不成立则返回false

          >大于号
            判断符号左侧的值是否大于右侧的
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 > 10                   关系不成立
            console.log("result = "+result)       控制台结果为false

            var result = 5 > 4                    关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 > 5                    关系不成立
            console.log("result = "+result)       控制台结果为false

          >=大于等于
            判断符号左侧的值是否大于或等于
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 >=  5                    关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 >=  4                    关系成立
            console.log("result = "+result)       控制台结果为true

          <小于号
            判断符号左侧的值是否小于右侧的
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 < 10                   关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 < 4                    关系不成立
            console.log("result = "+result)       控制台结果为false

          <小于等于
            判断符号左侧的值是否小于或等于
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 <=  5                  关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 <=  4                  关系不成立
            console.log("result = "+result)       控制台结果为false

          非数值的情况
          对于非数值进行比较时，会将其转换为数值，然后再比较
            console.log(1 > true)                  控制台结果为false
            console.log(1 >= true)                 控制台结果为true
            console.log(1 > "0")                   控制台结果为true
            console.log(10 > null)                 控制台结果为true
            console.log(true > false)              控制台结果为true

            任何值和NaN做比较都是false
            console.log(10 > "hello")      hello转换为数字是NaN       控制台结果为false
            console.log(10 > "undefined")  undefined转换为数字是NaN   控制台结果为false

            如果符号两侧的值都是字符串，不会将其转换成数字将其比较，而会分别比较字符串中字符的Unicode编码
            console.log("1" < "5")       Unicode编码0031<0035         控制台结果为true
            console.log("11" < "5")                  控制台结果为true
            console.log("a" < "b")                   控制台结果为true

            比较字符编码时是一位一位进行比较的，第一位a小于b，后面的bc就不比了，直接返回结果true
            console.log("abc" < "b")                 控制台结果为true
            console.log("11" < "5")      Unicode编码0031,0031<0035    控制台结果为true

            比较字符编码时是一位一位进行比较的，如果两位一样，则比较下一位(所以可以借用它来进行英文排序)
            console.log("bbc" < "b")                 控制台结果为false

            如果比较的两个字符串型的数字，可能会得到不可预期的结果
            所以注意，在比较两个字符串型的数字时，一定一定要转型
            console.log("1258965445687542" < +"5")   控制台结果为false
      */
    </script>
    <script id="相等运算符">
      /*
       *  相等运算符用来比较两个值是否相等，如果相等会返回true，否则会返回false
          使用==来做相等运算
          console.log(1 == 1)      控制台结果为true

          var a = 10
          console.log(a == 4)      控制台结果为false

          当使用==比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后再比较
          console.log("1" == 1)      控制台结果为true
          console.log("true" == "1") 控制台结果为true

          也有一个特殊情况null == 0 ,null没有转换为number
          console.log(null == 0)     控制台结果为false
      */
      /*
       *  undefined衍生自null
            所以这两个值做相等判断时，会返回true
            console.log(undefined == null)      控制台结果为true
      */
      /*
       *  NaN不和任何值相等，包括它本身
          console.log(NaN == NaN)      控制台结果为false

          var b = NaN (那我现在想判断b的值是否时NaN)
          console.log(NaN == NaN)      控制台结果为false，这个方法不行

          我们可以通过isNaN()函数来判断一个值是否时NaN
          如果该值时NaN，则返回true，否则返回false
          var b = NaN
          console.log(isNaN(b))        控制台结果为true
      */
      /*  不相等
       *  不相等运算符用来比较两个值是否不相等，如果不相等会返回true，否则会返回false
          使用!=来做不相等运算
          console.log(10 != 5)      控制台结果为true

          var a = 10
          console.log(10 != 10)      控制台结果为false

          console.log("abcd" != "abcd")      控制台结果为false

          !=也会对变量进行自动的类型转换，如果转换后相等，它会返回false
          console.log("1" != 1)      控制台结果为false
      */
      /*  全等
          判断两个值是否全等，它和相等类似，不同的是它不会做类型的自动转换
            如果两个值的类型不同，直接返回false
          使用===来做相等运算
          console.log("123" === 123)      控制台结果为false
          console.log(undefined === null)      控制台结果为false
      */
      /*  不全等
          判断两个值是否不全等，它和不等类似，不同的是它不会做类型的自动转换
            如果两个值的类型不同，直接返回true
          使用!==来做相等运算
          console.log("123" === 123)      控制台结果为true
      */
    </script>
    <script id="条件运算符">
      /*  条件运算符也叫三元运算符
            语法：
                条件表达式?语句1:语句2
              执行流程：
                      条件运算符在执行时，首先对条件表达式进行求值，
                        如果该值为true，则执行语句1，并返回执行结果
                        如果该值为false，则执行语句2，并返回执行结果

              true?alert("语句1"):alert("语句2")  执行结果为语句1
              false?alert("语句1"):alert("语句2")  执行结果为语句2

              var a = 10
              var b = 20
              a > b ?alert("a大"):alert("b大")  执行结果为b大
              var a = 30
              var b = 20
              a > b ?alert("a大"):alert("b大")  执行结果为a大

                        如果条件表达式的求值结果是一个非布尔值
                            会将其转换为布尔值，然后再进行运算

              "hello"?alert("语句1"):alert("语句2")  执行结果为语句1
              ""?alert("语句1"):alert("语句2")       执行结果为语句2

              获取a 和 b中的最大值
              var a = 10
              var b = 20
              var c = 40
              var max = a > b ? a : b;  (我要判断a是否大于b 如果a大于b我执行a，把变量a赋值给max.如果a小于b我执行b，把b赋值给max.最后max就是谁大就是谁)
              console.log("max = "+max)

              获取a b c中的最大值
              (接上一步接着比较最终得出结果)var max = max > c ? max : c  (我再拿max和c比，如果max大返回max，如果c大，那么c赋值给max)

              (一步到位获取a b c中的最大值)  //这种写法不推荐使用，不方便阅读
              var a = 10
              var b = 20
              var c = 40
              var max = a > b ? (a > c ? a : c) : (b > c ? b : c)     (如果a大于b则a大，a大执行第一个表达式 比较a和c谁大，如果a比c大那么a就是最大的了，如果a比c小那么c就是最大的了)
                                                                      (如果a大于b不成立，那就执行第二个表达式 比较b和c谁大，如果b比c大那么b就是最大的了，如果b比c小那么c就是最大的了)
              console.log("max = "+max)
      */
    </script>
    <script id="逗号运算符">
      /*  , 使用可以分割多个语句，一半可以在声明多个变量时使用
            var a;
            var b;
            var c;
          使用,运算符同时声明多个变量
            var a , b , c;
          可以声明多个变量并赋值
            var a = 1 , b = 2 , c = 3;
      */
    </script>
    <script id="运算符的优先级">
      /*  就和数学中一样，在JS中也有优先级，
          比如：先乘除 后加减

          var result = 1 + 2 * 3   结果为7

          如果||的优先级高，或者两个一样高(应从左往右算) 第一个为true就不看第二个了，1&&3，第一个true返回第二个 返回3
          如果&&的优先级高，那么先算2 && 3，第一个true返回第二个 返回3，1 || 3 第一个为true就不看第二个了 返回1
          var result = 1 || 2 && 3
          console.log("result = "+result) 控制台结果为result = 1 所以&&的优先级高

          在JS中有一个运算符优先级的表
            在表中越靠上优先级越高，优先级越高越优先计算
            如果优先级一样，则从左往右计算
          但是这个表我们并不需要记忆，如果遇到优先级不清楚
            可以使用()来改变优先级

          var result = (1 || 2) && 3        控制台结果为3
      */
    </script>
    <script id="代码块">
      /*
       整体了，一个{}中的语句我们也称为一个代码块
              {}后不用编写;
            JS中的代码块，只具有分组的作用，没有其它的用途
              代码块内部的内容，在外部是完全可见的
            {
              alert("hello")
              console.log("你好")*  我们的程序是由一条一条语句构成的
            语句是按照自上向下的顺序一条一条执行的
            alert("hello")
            console.log("你好")
            document.write("语句")

            在JS中可以使用{}为语句分组，同一个{}中的语句我们称为是一组语句，它们要么都执行，要么都不执行
              换句话说它们就是一个
              document.write("语句")
            }
      */
    </script>
    <script id="if语句">
      /*
       *  流程控制语句
            JS中的程序时从上到下一条一条执行的
              alert("hello")
              console.log("你好")
              但从上到下一点也不智能，很傻。(就像一个傻小子，他爸让他出门买酒，傻小子开门一看天上正下刀子呢，但一想他爸让他买酒，还是迈开脚出门了，刚走两步被天上掉下的刀子插死了)
            通过流程控制语句可以控制程序执行流程
              使程序可以根据一定的条件来选择执行
            语句的分类:
              1:条件判断语句(我要对一个条件进行判断，如果条件成立执行，如果条件不成立则不执行)
              2:条件分支语句(满足条件一的话我执行条件一路线，满足条件二我执行条件二路线)
              3:循环语句(反复执行某一条语句)

       *  条件判断语句：
            使用条件判断语句可以在执行某个语句之前进行判断，
              如果条件成立，才会执行语句，如果条件不成立则语句不执行
            if语句
            语法一：
              if(条件表达式){
                语句
              }

              if语句在执行时，会先对条件表达式进行求值判断，
                如果条件表达式的值为true，则执行if后的语句
                如果条件表达式的值为false，则不会执行if后的语句
                if(true) alert("你猜我出来吗")                   执行
                if(false) alert("你猜我出来吗")                  不执行

                var a = 10
                if (a > 10) alert("a比10大")                    不执行

                var a = 11
                if (a > 10)
                    alert("a比10大")                    执行
                    alert("谁也管不了我")                执行

              if语句只能控制紧随其后的那个语句
                var a = 10
                if (a > 10)
                    alert("a比10大")                    不执行
                    alert("谁也管不了我")                执行

              如果希望if语句可以控制多条语句，可以将这些语句统一放到代码块中
                如果if这个条件表达式成立，则代码块里的代码都会执行，如果条件不成立，都不执行
                  var a = 10
                  if (a > 10){
                      alert("a比10大")
                      alert("谁也管不了我")
                  }                                     都不执行

              if语句后的代码块不是必须的，但是我们在开发中还是尽量写上代码块，即使if后只有一条语句

              与&& 需要同时满足多个条件时才会执行
              或|| 只要有一个满足就行
              var a = 25
              if (a > 10 && a <= 25){
                  alert("a大于10，并且a小于等于25")
              }                                         执行

            if语句
            语法二：
              if(表达式){
                语句
              }else{
                语句
              }

              if...else...语句
                当该语句执行时，会先对if后的条件表达式求值判断
                  如果该值为true,则执行if后的语句
                  如果该值为false,则执行esle后的语句

                  var age = 50
                  if(age >= 60){
                    alert("你已经退休了")
                  } else{
                    alert("你还没有退休")
                  }                                      你还没有退休

            if语句
            语法三：
              if(表达式){
                语句
              }else if{
                语句
              }else if{
                语句
              }else{
                语句
              }

              if...else if...else语句
                当该语句执行时，会从上到下依次对条件表达式进行求值判断
                  如果值为true,则执行当前语句。
                  如果值为false,则继续向下判断
                  如果所有的条件都不满足，则执行最后else后的语句
                  该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句
                  var age = 70
                  if(age > 100){
                    alert("活着挺没意思的")
                  } else if(age > 80){
                    alert("你也老大不小的了")
                  } else if(age > 60){
                    alert("你已经退休了")
                  } else if(age > 30){
                    alert("你已经中年了")
                  } else if(age > 18){
                    alert("你已经成年了")
                  } else{
                    alert("你还是个小孩子")
                  }                                      你已经退休了
      */
    </script>
    <script id="if练习">
      /*  从键盘输入小明的期末成绩
          当成绩为100时，奖励一辆BMW
          当成绩为(80~99)时，奖励一台iphone13pro
          当成绩为(60~80)时，奖励一本参考书
          其它时，什么奖励都没有

          prompt()可以弹出一个提示框，该提示框中会带有一个文本框，
            用户可以在文本框中输入一段内容，该函数需要一个字符串""作为参数
            该字符串会作为提示框的提升文字
          用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容

       *  var score = Number(prompt("请输入小明的期末成绩(0~100):"));
          if (score > 100 || score < 0 || isNaN(score)) {
            alert("请输入范围内的分数");
          } else {
            if (score == 100) {
              alert("奖励一辆BMW");
            } else if (score >= 80) {
              alert("奖励一台iphone13pro");
            } else if (score >= 60) {
              alert("奖励一本参考书");
            } else{
              alert("什么奖励都没有");
            }
          }

       *  大家知道，男大当婚，女大当嫁，那么女方家长要嫁女儿，当然要提出一定的条件
          高：180cm以上；
          富：1000万以上；
          帅：500以上；
          如果这三个条件同时满足，则："我一定要嫁给他"
          如果这三个条件有为真的情况，则："嫁把，比上不足比下有余"
          如果这三个条件都不满足，则："不嫁"

          var height = prompt("请输入身高(cm):")
          var money = prompt("请输入财富(万):")
          var face = prompt("请输入颜值(px):")
          if (height > 180 && money > 1000 && face > 500){
            alert("我一定要嫁给他")
          } else if(height || 180 && money || 1000 && face || 500){
            alert("嫁把，比上不足比下有余")
          } else{
            alert("不嫁")
          }

       *  编写程序，由键盘输入三个整数分别存入变量num1、num2、num3,
          对它们进行排序，并且从小到大输出。
          //prompt()函数的返回值时string类型的，直接在prompt()函数前加一个+，可以将它的返回值统一转换为number类型
          var num1 = +prompt("请输入第一个数")
          var num2 = +prompt("请输入第一个数")
          var num3 = +prompt("请输入第一个数")
          //找到3个数中最小的数
          if(num1 < num2 && num1 < num 3){
            //num1最小，比较num2和num3
            if(num2 < num3){
              alert(num1 + "," num2 + ","+num3)
            }else{
              alert(num1 + "," num3 + ","+num2)
            }
          } else if(num2 < num1 && num2 < num3){
            //num2最小，比较num1和num3
            if(num1 < num3){
              alert(num2 + "," num1 + ","+num3)
            } else{
              alert(num2 + "," num3 + ","+num1)
            }
          } else(num3 < num1 && num3 < num2){
            //num3最小，比较num1和num2
            if(num1 > num2){
              alert(num3 +"," num1 + ","+num2)
            } else{
              alert(num3 + "," num2 + ","+num1)
            }
          }
      */
    </script>
    <script id="条件分支语句">
      /*
       *  条件分支语句也叫switch语句
            语法：
              switch(条件表达式){
                case表达式:
                  语句
                  break
                case表达式:
                  语句
                  break
                default:
                  语句
                  break
              }
            执行流程：
              switch...case...语句
              在执行时会依次将case后的表达式和switch后的条件表达式的值进行全等比较
                如果比较结果为true,则从当前case处开始执行代码(当前case后的所有的代码都会执行)，我们可以在case的语句后面跟着一个break关键字，这样可以确保只会执行当前case后的语句，而不会执行其它的代码
                如果比较结果为flase,则继续向下比较
                如果所以的比较结果都为false，则只执行default语句
              switch语句和if语句的功能实际上有重复的，使用switch可以实现if的功能，同样使用if也可以实现switch的功能，所以我们使用时，可以根据自己的习惯选择

          根据num的值，输出对应的中文
          var num = 3
          if(num == 1){
            console.log("一")
          }else if(num == 2){
            console.log("二")
          }else if(num == 3){
            console.log("三")
          }                       这样做对是对的，只是太麻烦，每一个都在和num做相等的比较

          var num = 1
          switch(num){
            case 1:
              console.log("一")
          }

          var num = 2
          switch(num){
            case 1:               在执行时会依次将case后的表达式和switch后的条件表达式的值进行全等比较
              console.log("一")
            case 2:               比较结果为true,则从当前case处开始执行代码(当前case后的所有的代码都会执行)
              console.log("二")
            case 3:
              console.log("三")
            case 4:
              console.log("四")   控制台输出二 三 四
          }

       *  使用break可以退出switch语句
          如下所例，num = 2和case 2是全等的，全等则执行case 2后面的所有代码
            我们可以在case 2的语句后面跟着一个break关键字，这样可以确保只会执行当前case后的语句，而不会执行后面的代码

          var num = 2
          switch(num){
            case 1:               在执行时会依次将case后的表达式和switch后的条件表达式的值进行全等比较
              console.log("一")
            case 2:               比较结果为true,则从当前case处开始执行代码(当前case后的所有的代码都会执行)
              console.log("二")
              break;
            case 3:
              console.log("三")
            case 4:
              console.log("四")   控制台输出二 三 四
            default:
              console.log("非法数字")
          }
      */
    </script>
    <script id="switch练习">
      /*

       *  对于成绩大于60分的，输出"合格"。低于60分的，输出"不合格"
          方法一：
          var score = 60
          switch(score){
            case 60:
            case 61:
            case 62:
              console.log("合格")
              break;
          }

          6x等于60几
          7x
          8x
          9x
          100
          这几种情况都是合格
          从60~100数很多，一个个写不现时，那想想能不能把情况合并一下呢？
          6x / 10 = 6x
          7x / 10 = 7x
          8x / 10 = 8x
          9x / 10 = 9x      无论是91还是99/10 都得9，只不过不同的是91除9余1，99除9余9
          100 / 10 = 10

          var score = Number(prompt("请输入你的分数"));
          switch (parseInt(score / 10)) {
            case 10:
            case 9:
            case 8:
            case 7:
            case 6:
              console.log("合格");
              break;
            default:
              console.log("不合格");
              break;
          }

          方法二：
            var score = Number(prompt("请输入你的分数"));
            switch (true) {
              case score >= 60:           拿case后面的score >= 60:和true做比较，如果我case后面的值是true则执行下面的合格。>= 60如果成立那么返回true 和它全等 执行下面的合格。
                console.log("合格");
                break;
              default:
                console.log("不合格");
                break;
            }
      */
    </script>
    <script id="循环语句">
      /*
       *  向页面中输出连续的数字
          document.write(1);
          document.write(2);  但是这样写完这两个连一块了12，我希望我写完 1在一行，2在一行

          document.write(1+"<br />");
          document.write(2+"<br />");
          document.write(3+"<br />");
          document.write(4+"<br />");  在网页中输出，我们可以使用br标签，进行换行

          但是写1234有点麻烦，我还得一个个写，看这个数一直在自增，那不如这么写
          var n = 1
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")

          但发现这块有个问题，输出半天，向页面输出这6个数字，每一行输出一个，每一行执行的都是一摸一样的 这样做太麻烦了，不方便
          那我现在希望 反复的执行这一条语句多少多少次，这时候我们就可以用到循环语句

       *  循环语句：
            通过循环语句可以反复的执行一段代码多次
       *  while循环
            语法：
              while(条件表达式){
                语句
              }
            while语句在执行时，
              先对条件表达式进行求值判断，
                如果值为true，则执行循环体
                  循环体执行完毕之后，继续对表达式进行判断
                  如果为true，则继续执行循环体，以此类推
                如果值为false，则终止循环

            //像这种将条件表达式写死 为true的循环，叫做死循环
            //该循环不会停止，除非浏览器关闭，死循环在开发中慎用
                var n = 1
                while(true){
                  alert(n++)
                }                对话框 1 2 3 4 5 6以此类推一直在执行，不停的在往外冒

            //我想循环停止怎么办呢？可以使用break来终止循环
                var n = 1
                while(true){
                  alert(n++)
                  break;
                }                这么写的话，执行1后直接退出，那我写循环就没有了


            //我们可以在break来个判断，只有n等于10的时候才终止
                var n = 1
                while(true){
                  alert(n++)
                  if(n == 10){
                    break;
                  }
                }
            while循环更常见的一个写法，我们来看看
            //创建一个循环，往往需要三个步骤
              //1.初始化一个变量
                var i = 0
              //2.在循环中设置一个条件表达式 //以下为例，判断i是否小于10，只有i小于10循环才会执行
                while(i < 10){
                  alert(i)
                  //3.定义一个更新表达式，每次更新初始化变量. //i++ 循环每执行一次 i自增一个.执行第一次i变成1，执行第二次i变成2，直到执行到10循环停止，所以这样我们的循环变成了一个执行10次的一个循环
                  i++;
                }                对话框 1 2 3 4 5 6 7 8 9没了，到10不执行

       *  do while循环
            语法：
              do{
                语句
              }while(条件表达式)
            执行流程：
              do while语句在执行时，会先执行循环体，
              循环体执行完毕以后，会对while后的条件表达式进行判断，
                如果结果为true，则继续执行循环体，执行完毕以后继续判断 以此类推
                如果结果为false，则终止循环

              while和do while实际上这两个语句功能类似，不同的是while是先判断后执行，而do while是先执行，后判断
              do while可以保证循环体至少执行一次，而while不能
      */
    </script>
    <script id="while练习">
      /*
       *  假如投资的年利率为5%，试求从一千块增长到五千块，需要花费多少年
          1000 1000*1.05
          1050 1050*1.05

          定义一个变量，表示钱的钱数
          var money = 1000;
          //第一年投资的钱数
          money = money * 1.05
          //第二年投资的钱数
          money = money * 1.05
          //第三年投资的钱数
          money = money * 1.05
          console.log(money)

          定义一个while循环来计算每年的钱数
          while(money < 5000){               //判断钱是否小于5000，到了5000循环停止
            money = money * 1.05             //循环每执行一次过了一年，每执行一次增长一次
          }
          console.log(money)

          年数怎么求？
          我们需要在循环体外定义一个计数器变量，统计保存我们代码的执行次数
          var money = Number(prompt("请输入你投资的本金"));
          var money = 1000;
          var count = 0
          while(money < 5000){               //判断钱是否小于5000，到了5000循环停止
            money = money * 1.05             //循环每执行一次过了一年，每执行一次增长一次
            count++;                         //循环每执行一次我们让count自增一个
          }
          console.log("一共需要"+count+"年")  一共需要三十三年


       *  从键盘输入小明的期末成绩
          当成绩为100时，奖励一辆BMW
          当成绩为(80~99)时，奖励一台iphone13pro
          当成绩为(60~80)时，奖励一本参考书
          其它时，什么奖励都没有

          //用户输入错误 我希望用户可以再输入一遍，那我们可以将prompt放入到循环中
          while (true) {
            var score = prompt("请输入小明的期末成绩(0~100):");
            //判断用户输入的值是否合法，用户输入合法则退出循环
            if (score >= 0 && score <= 100) {
              break;
            }
            alert("请输入有效的分数");
          }
          if (score > 100 || score < 0 || isNaN(score)) {
            alert("请输入范围内的分数");
          } else {
            if (score == 100) {
              alert("奖励一辆BMW");
            } else if (score >= 80) {
              alert("奖励一台iphone13pro");
            } else if (score >= 60) {
              alert("奖励一本参考书");
            } else {
              alert("什么奖励都没有");
            }
          }
      */
    </script>
    <script id="for循环">
      /*
       *  for语句，也是一个循环语句，也称为for循环
            在for循环中，为我们提供了专门的位置来摆放三个表达式：
              1.初始化表达式
              2.条件表达式
              3.更新表达式
            for循环的语法：
              for(①初始化表达式;②条件表达式;④更新表达式){
                ③语句
              }
              for(var i = 0 ; i < 10 ; i++){
                alert(i)
              }
            for循环的执行流程：
              ①执行初始化表达式，初始化变量(初始化表达式只会执行一次，就是在第一次的时候执行的)
              ②执行初始化表达式，判断是否执行循环
                如果为true,则执行循环体③
                如果为false,则终止循环
              ④执行更新表达式，更新表达式执行完毕 继续重复②
            for循环中的三个部分可以省略，也可以写在外部
              var i = 0
              for(;i < 10;){
                alert(i++)
              }
            如果在for循环中不写任何的表达式，只有两个;
              此时循环是一个死循环 会一直执行下去，所以慎用
              for(;;){
                alert("hello")
              }
      */
    </script>
    <script id="for循环练习">
      /*
       *  打印1-100之间所有奇数之和
          ①//打印1-100之间的数
            for(var i = 1 ; i <= 100 ; i++){
              alert(i)
            }
          ②//判断i是否为奇数。不能被2整除的数就是奇数。如果i除以2有余数则证明i是奇数
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 2 != 0){
                console.log(i)
              }
            }
          ③//那我现在的i有多少个？好多呀，那我需要把这些i一个一个加起来。加的话是不是得有一个地方保存这个结果呀
           //所以我们在循环的外面，创建一个变量，用来保存奇数之和
            var sum = 0
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 2 != 0){
                sum = sum + i
              }
            }
            console.log("奇数之和为："+sum)


       *  打印1-100之间所有7的倍数的个数及总和
          ①//打印1-100之间的数
            for(var i = 1 ; i <= 100 ; i++){
              alert(i)
            }
          ②//判断i是否是7的倍数。i能被7整除，就意味着i是7的倍数
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 7 == 0){
                console.log(i)
              }
            }
          ③//在循环的外面，创建一个变量，用来保存7的倍数之和
            var sum = 0
            var count = 0
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 7 == 0){
                sum = sum + i
                count++
              }
            }
            console.log("7的倍数之和为："+sum)      //输出语句写在循环外面，因为我们只需要输出一次
            console.log("7的倍数的个数为："+count)  //使计数器自增1

       *  水仙花数
          水仙花数是值一个三位数，它的每 个位上的数字3次幂之和等于它的本身。
          (例如：13 + 53 + 33 = 153)，请打印所有的水仙花数
          ①//打印所有的三位数
          for(var i = 100 ; i < 1000 ; i++){
            console.log(i)parseInt()
          }
          ②//获取i的百位 十位 个位的数字
            //获取百位的数字
            var bai = parseInt(i / 100)                  //我们要的是整数位，小数位不要，所以我需要对它取整parseInt()
            //获取十位的数字
            var shi = parseInt((i - bai * 100)/10)       //355-百位等于55 55/10等于5.5 取整为5
            //获取各位的数字
            var ge  = i % 10
          ③//判断i是否是水仙花数
          if(bai * bai * bai + shi * shi * shi + ge * ge * ge == i){
            console.log(i)
          }

       *  在页面中接收一个用户输入的数字，并判断该数是否是质数
            质数：只能被1和它自身整除的数，1不是质数也不是合数，质数必须是大于1的自然数
          var num = prompt("请输入一个大于1的整数")                    //判断该值是否合法
          var flag = true                                            //创建一个变量来保存当前数的状态.为什么等于true呢?我们默认当前num是质数
          if(num <= 1){
            alert("该值不合法")
          }else{                                                     //判断num是否是质数  //获取2~num之间的数(把用户输入的num这些有可能整除的数取出来)
            for(i = 2 ; i < num ; i++){                              //i=2 i小于num(i从2开始 如果num是10，i就是2到9这些数)
              if(num % i == 0){                                      //判断num是否能被i整除.如果num能被i整除，则说明num一定不是质数
                flag = false
              }
            }
            //如果num是质数则输出                                                         //输出不能在循环体里面输出，因为结果是再for循环执行完了才出来的，得再for循环外输出。
            if(flag){                                                                   //所以我需要在这输出，但是问题又来了，我在这儿能不能知道for循环结果 不能。我需要结果从for循环里传出来，需要for循环的结果告诉下面num是不是质数，所以我在外面创建了一个变量，我默认当前num是质数，到了for循环体判断能否被i整除 能被整除一定不是质数，故flag变成false.变成false后，一到下面 我就知道它不是质数了
              alert(num + "是质数！")
            }else{
              alert(num + "不是质数！")
            }
          }
      */
    </script>
    <script id="嵌套的for循环">
      /*  需求
            通过程序，在页面中输出如下图形
            *****
            *****
            *****
            *****
            *****
          //通过一个for循环来输出图形
          //这个for循环执行几次，图形的高度就是多少
          //它可以控制图形的高度
          for (i = 0; i < 5; i++) {
            document.write("*****<br />");     我想高度是20，我可以把i<5改成i<20
          }
          //可是高度灵活 宽度不灵活

       *  在循环的内部再创建一个循环，用来控制图形的宽度
          目前我们外部的for循环执行1次，内部的就会执行5次
          内层循环可以决定图形的宽度 执行几次，图形的宽度就是多少
          for (i = 0; i < 5; i++) {
            for (j = 0; j < 5; j++) {    里面的for循环我想宽度是20，我可以把i<5改成i<20
              document.write("*");
            }
            document.write("<br />");    执行换行
          }
          现在输出的图形，我感觉不太好看 它们行与行之间距离有点远，*与*之间的距离几句为0，我希望它们之间距离远一点
            那我们在document.write("* ");加了个空格，有用。再加空格就没用了，因为最终是写到网页里的，写多少空格都当成一个 所以想要它起作用就不能这么写了
            document.write("*&nbsp;&nbsp;");

       *  需求
            通过程序，在页面中输出如下图形
            *               1(第一行)     <1(宽度一个*, j<1)     i=0(i+1正好等于行号)
            **              2     <2      i=1
            ***             3     <3      i=2
            ****            4     <4      i=3
            *****           5     <5      i=4

          for (i = 0; i < 5; i++) {
            for (j = 0; j < i + 1; j++) {         j < i + 1这样 第一次执行的时候i是0，j < 1，小于1那么第一行输出一个*。第二行的时候i是1，j < 2，小于2那么第二行输出两个*
              document.write("*");
            }
            document.write("<br />");    执行换行
          }

      */

    </script>
    <script id="函数">
      /*
       *  函数function
            函数也是一个对象
            函数中可以封装一些功能(代码)，在有需要的时候可以执行这些功能(代码)
            函数中可以保存一些代码在需要的时候使用
            使用typeof检查函数对象时，会返回function

          //创建一个函数对象
            var fun = new Function()
            console.log(typeof fun)
          //可以将要封装的代码以字符串的形式传递给构造函数    //(换句话说 在构造函数里 我可以传一个字符串)
            var fun = new function("console.log('hello 这是我的第一个函数');")    //我这个函数构造里传的是一个字符串，但是这字符串有特点了，这字符串是一段js代码，等于是我现在把这一段代码存到了我们函数对象里
            console.log(fun)                                                    //控制台显示console.log('hello 这是我的第一个函数');
          //封装到函数中的代码不会立即执行                  //(也就是说我仅仅把它给存起来了，就像枪一样 我把子弹给装上了，它得等我开枪)
          //函数中的代码会在函数调用的时候执行
          //调用函数 语法：
              函数对象()
              fun()
          //当调用函数时，函数中封装的代码会按照我编写的顺序执行
            var fun = new function("console.log('hello 这是我的第一个函数');")
            fun()                                                               //控制台显示 hello 这是我的第一个函数
          //调用几次执行几次
            var fun = new function("console.log('hello 这是我的第一个函数');")
            fun()                                                               //控制台显示 hello 这是我的第一个函数
            fun()                                                               //控制台显示 hello 这是我的第一个函数
            fun()                                                               //控制台显示 hello 这是我的第一个函数
            //这有什么好处？假如我想重复的去执行这行代码，我在24行想用我调用一下，我在240行想用我调一下，用起来比较方便。并且我想修改的话不用分别修改
          不过我们在实际开发中很少使用构造函数来创建一个函数对象

       *  使用函数声明来创建一个函数
            语法：
              function 函数名([形参1，形参2...形参n]){                            //[]意思表示可选的，里面的写不写都行,{}里函数体
                语句
              }

              function fun2 (){

              }
              console.log(fun2)                                       //控制台显示function fun2 (){}里没有代码，因为我还没有往里填
          //那现在我要封装代码怎么封装啊?直接写在函数体里
              function fun2 (){
                console.log("这是我的第二个函数")
              }
              fun2()                                                  //控制台显示这是我的第二个函数(我可以在函数体里封装大量的代码，调用的时候只需要调用变量名fun2()一行代码搞定)

       *  使用函数表达式来创建一个函数
            语法：
              var 函数名 = function ([形参1，形参2...形参n]){
                语句
              }
              //匿名函数
              function(){
                console.log("我是匿名函数中封装的代码")
              }                                                       //匿名函数无意义，因为没用名，写完也用不了它
              //所谓函数表达式就是创建一个匿名函数，然后将匿名函数的对象赋值给变量
              var fun3 = function ([形参1，形参2...形参n]){
                console.log("我是匿名函数中封装的代码")
              };
              fun3()
      */
    </script>
    <script id="函数的参数">
      /*  上面我们知道函数的方式及使用，但是函数的里面是封装的一些功能，封装的一些可执行的代码的，但我们发现 现在我们的功能没有实际上的意义，所以这里面我们要有有那么一点意义的函数
       *  函数的参数
          在函数的参数之前呢，我们先创建一个函数
          那既然我们说了，函数的里面是封装的一些功能的，那我就要定一个具有一定功能的函数
          比如说：定义一个求两个数和的函数
            function sum(){
              console.log(1+1)
            }                            //现在保存 没执行?调用
            sum()                        //保存 控制台结果位2.
          //现在的问题是我这是求两个和的函数，但只会算1+1 写死了
          function sum(){
              var a = 1
              var b = 1
              console.log(a+b)
            }
            sum()                        //保存 控制台结果位还是2.这比刚才还麻烦了，但是已经有进步了，我知道使用变量了
          //但是问题来了，我这变量的值是死的呀，那还不如不写呢，那我这两个值什么时候定啊，在调用的时候定。如果在调用的时候我希望是2+3，那就是a=2 b=3。
          //我希望在我调用的时候，我才决定我要算谁+谁。定义的时候不定，在调用的时候定
       *  可以在函数的()中来指定一个或多个形参(形式参数) //什么是形式参数 形式上的，它没有值 我先给你占个地儿
          多个形参之间使用,隔开。声明形参就相当于在函数的内部声明了对应的变量
            但是并不赋值
            function sum(a,b){
              console.log(a+b)
            }
       *  在调用函数时，可以在()中指定实参(实际参数)
              实参将会赋值给函数中对应的形参
            sum(1,2)    //控制台结果位还是3        所以(1，2)就相当于在函数体中写了一个var a = 1 ();var b = 2

       *  调用函数时 解析器不会检查实参的类型
             所以要注意，是否有可能会接收到非法的参数，
               如果有可能，则需要对参数进行类型的检查
          函数的实参可以是任意的数据类型
           function sum(a,b){
              console.log(a+b)
            }
           sum(123,"hello")            //控制台结果是123hello
           function sum(a,b){
              console.log(a+b)
            }
           sum(true,false)             //控制台结果是1

       *  调用函数时，解析器也不会检查实参的数量
            多余实参不会被赋值
          如果实参的数量少于形参的数量，则没有对应实参的形参将时undefined
          function sum(a,b){
              console.log(a+b)
            }
           sum(1,2,true,false)             //控制台结果是3
      */
    </script>
    <script id="返回值">
      /*  首先 我们先创建一个函数，用来计算三个数的和
          function sum(a,b,c){
            console.log(a+b+b)
          }
          sum(4,7,8)   //控制台结果19
          //算完的结果就给我输出出来了，你说这种东西它好不好啊？
          //这个19的值是不是我想输出的呢？不一定。结果算出来我可能想干别的去用。就像你去称体重，刚站秤上 旁边有一人看见了给你念出来了说他体重两百！
            那你是不希望他念出来啊？不用 我希望我称完这个体重 知道结果就行了。
            同理 我只需要一个结果，而不需要你替我来处理这个结果
            往往执行一个函数时，是需要将这个结果返回的，而不是输出。那问题来了 我们怎么将这个结果返回呢?

       *  可以使用return,来设置返回的值
            语法：
              return 值
              return //如果return后面不跟值，就相当于return undefined
            return后的值将会作为函数的执行结果返回，
              可以定义一个变量，来接收该结果


          function sum(a,b,c){
            //console.log(a+b+b)
            var d = a + b + c
            return d
          }
          //调用函数
          //变量result的值就是函数的执行结果
          //函数返回什么result的值就是什么
          var result = sun(4,7,8)
          console.log("result = "+result)            //控制台结果是result=19

          在函数中return下面的语句都不会执行
            function sum(a,b,c){
            var d = a + b + c
            return d
            alery=t("hello")                         //控制台结果是result=19，alert没有执行
            }
            var result = sun(4,7,8)
            console.log("result = "+result)

          如果return语句后面不跟值，就相当于返回一个undefined
            function sum(a,b,c){
            var d = a + b + c
            return
            }
            var result = sun(4,7,8)
            console.log("result = "+result)          //控制台结果是result undefined

          如果函数中不写return，则也会返回undefined
            function sum(a,b,c){
            var d = a + b + c
            }
            var result = sun(4,7,8)
            console.log("result = "+result)          //控制台结果是result undefined

          return语句后可以跟任意类型的值
            function sum(a,b,c){
            var d = a + b + c
            return "hello"
            }
            var result = sun(4,7,8)
            console.log("result = "+result)          //控制台结果是result=hello
       *
      */


    </script>
    <script type="xxx" id="函数练习">
      // 判断一个数是不是素数
      //  是的话返回true
      //  不是的话返回false
      var n = Number(prompt("请输入一个数是不是素数:"));
      function isPrime(n) {
        for (var i = 2; i * i <= n; i++) {
          if (n % i == 0) {
            return false; //return 语句会终止函数的执行并返回函数的值。
          }
        }
        return true;
      }
      var result = isPrime(n);
      console.log(result);
    </script>

    <script type="xxx" id="函数练习">
      // 如果一个数与7有关就返回真，否则返回假
      //    (与7有关，是7的倍数或任意位上有7)
      var n = Number(prompt("请输入"));
      function qiao7(n) {
        if (n % 7 == 0) {
          return true; //但它不是7的倍数也不代表它就与7无关，因为还要考虑它各个位上是不是7
        }
        while (n > 0) {
          var digit = n % 10; //123 3   12 2
          if (digit == 7) {
            return true;
          }
          n = (n - digit) / 10; //123-3/10=12   12-2/10=1
        }
        return false;
      }
      console.log(qiao7(n));
    </script>

    <script type="xxx" id="函数练习">
      //给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。
      //丑数 就是只包含质因数 2、3 和/或 5 的正整数。
      //解题思路 怎样判断呢？
      //就拿这个n除以2 除以3 除以5，要是能除我就一直除 除到最后的话能把2、3、5这些数除完只剩1
      var isUgly = function(n) {
        while (n % 2 == 0){ //如果n % 2 == 0说明它可以除以2，n就等于n除以2。除一次是不够的，比如20。20/2=10，10还能再除以2，所以while循环。
            n = n / 2
        }
        while (n % 3 == 0) {
            n = n / 3
        }
        while (n % 5 == 0){
            n = n / 5
        }
        return n == 1 //最后它真的能够在上面的一直除来除去的过程中 把2、3、5的因子除完并且它真的是丑数的话，那么它只会剩1
    };
    </script>

    <script id="数组的基本用法">
      /*
       *  数组就是一系列数字，有序的集合
          一个数里面可以存多个东西
          存数：
            var a = []                   创建空数组
            var a = [1,2,3,4,5]          创建非空数组
            a
            (5) 1,2,3,4,5

            它是有序集合，所以这些数在数组里面是有顺序的，有点像数列
            数组里面的元素是从0开始编号的，所以这个1它是第0项，我们称它下标为0或者索引是0。

            那我怎么拿到它的第一项，第二项，第三项呢？
            a[里面写上下标]
            例如a[2]，表示数组中的第3项 已经拿到3了

            a[2]=8,那么a这个数组的第二项由3变成8了
            a
            (5) 1,2,8,4,5
            a[4]=9,那么a这个数组的第二项由3变成8了
            a
            (5) 1,2,8,4,9

            总之a[4]这是个表达式，所以哪里可以写表达式，哪里就可以写它。哪里可以写它，哪里就可以写表达式。哪里是表达式，哪里就可以换成它。
            比如说a[4]++
            9
            a
            (5) 1,2,8,4,10

          a.length 得到数组的长度
          5 但是长度为5的时候最大下标最大索引是4，因为它是从0开始编号的

          a.push(2) 往数组的末尾添加一项
          6 push返回6什么意思呢？ 是push完以后 这个数组有多长。同时它把这个2放到了数组的末尾
          a
          (6) 1,2,8,4,10,2
          a.push(3)
          7
          a
          (7) 1,2,8,4,10,2,3
          a.push(0,9,1,8)
          11
          a
          (11) 1,2,8,4,10,2,3,0,9,1,8

          a.unshift(8) 从数组的前面增加一项
          (12) 8,1,2,8,4,10,2,3,0,9,1,8
          a.unshift(1,2,3)
          (15) 1,2,3,8,1,2,8,4,10,2,3,0,9,1,8

          a.pop() 从数组的末尾删除一项，并且pop会把删除的最后一项返回给你。pop的时候一次只能pop一个，不接收参数，传参没有任何效果
          8
          a
          (14) 1,2,3,8,1,2,8,4,10,2,3,0,9,1

          a.shift() 从数组的前面删除一项
          1
          a.shift()
          2
          a.shift()
          3
          a.shift()
          8
          a.shift()
          1
          a.shift()
          2
          a
          (8) 8,4,10,2,3,0,9,1

          总结：
               unshift 数组前面增加
               shift  数组前面删除
               push  数组后面增加
               pop  数组后面删除

               素组是值的有序集合
               var a = [] 创建空数组
               var a = [1,2,3,4] 创建非空数组
               console.log(a[0]) 取出数组第一项，即下标/索引为0的项
               console.log(a[1]) 取出数组第二项，即下标/索引为1的项
               a[2]=888 给素组下标2号元素赋值
               a.length 直接得到数组长度
               a.push(5) 向数组末尾增加元素，并返回新的长度
               a.push(5,6) 可以向素组末尾一次性增加多个元素，同样会返回新的长度
               a.pop() 删除并返回数组最后一项，一次只能删除一项
               a.unshift(9) 向数组前面增加元素，并返回新的长度
               a.unshift(10,11) 可以向数组前面一次性增加多个元素，同样会返回新的长度
               a.shift() 删除并返回数组第一项，一次只能删除一项

          a
          (8) 8,4,10,2,3,0,9,1
          a[3]是2
          a[a[3]] a[2] 10

          i=2
          a[i*i] 即4的下标 第5项 3

          a=[Nan,true,['a','b','c'],5,5]
          那么我想去出c
          a[2][2]

          练习：
          //输入一个n 再输入n个数，对这n个数倒叙输出
          var n = Number(prompt())
          var a = []//首先创建一个数组
          for(var i =0 ; i < n; i++){
            var number = Number(prompt())
            a.push(number)//输入完这n个数我就把这些数添加到数组里面去
          }
          for(var i = a.length - 1 ; i >= 0 ; i--){ //倒叙循环 i下标2，1，0
            console.log(a[i])
          }


      /*



    </script>

  <!-- </head> -->
  <body>
    <!-- 可以将js代码编写到标签的onclick属性中
    虽然可以写在标签的属性中，但是它们属于结构与行为偶合，不方便我们维护-->
      <!-- <button onclick="alert('讨厌，你点我干嘛~~');">点我一下</button> -->
    <!-- 当我们点击按钮时，js代码才会执行 -->

    <!-- 可以将js代码写在超链接href属性中 -->
      <!-- <a href="javascript:alert('让你点你就点~');">你也点我一下</a> -->
    <!-- 当我们点击超链接时，会执行我们的js代码 -->
      <!-- <a href="javascript:;">你也点我一下</a> -->
    <!-- 我们希望超链接点完没有反应，通过js处理一些功能 -->
  </body>
</html>
