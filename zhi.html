 <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script type="text/javascript" src=""></script>
    <script type="xxx">
      console.log(2021);
      console.log(2021 * 2);
      console.log(2021 * 2021);
      console.log(2021 * 2021 * 2021 * 2021 * 2021);
      console.log(201 > 50 && 2021 > 100);
      console.log(2021 % 2 == 1);
      console.log(2021 % 2 == 0);
      console.log(2021 % 10);
      console.log(2021 % 100);
      console.log(2021 > 200 && 2021 % 3 && 2021 % 7 != 0);
      console.log((1864 - (1864 % 100)) / 100 + 1);
    </script>
    <script type="">
      // 控制浏览器弹出一个警告框
      alert("这是我的第一行js代码");
      // 输出在浏览器窗口

      // 让计算机在页面中输出一个内容
      // document(文档的意思，一个网页就是一个文档)

      document.write("写一个文档 看我出不出来");
      // 输出在在body 页面中

      // 向控制台输出一个内容
      console.log("你猜我在哪儿出来呢？");
      // 输出在控制台

      // js代码指令是从上到下一条一条执行的;
      alert("这是我的第一行代码");
      document.write("写一个文档 看我出不出来");
      console.log("你猜我在哪儿出来呢？");
      // 以上三个都是输出语句
    </script>
    <script type="字面量和变量">
      /*
        字面量 都是一些不可改变的值 例如:1 2 3 4 5 6
        字面量都是可以直接使用的,但是我们一半不会直接使用字面量

        *变量 可以保存我们的字面量 例如:x=1;
        而且变量的值是可以任意改变的，变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量
        变量还可以对字面量进行描述 例如 age=80;

        *声明变量
        在js中使用var关键字来声明一个变量 例如:var a;

        *为变量赋值
        a=123;

        *声明变量和赋值同时进行
        var age = 80;
        age = 81;(赋值后面的这个有效)
        console.log(age)
      */
    </script>
    <script type="标识符">
      /*
        *标识符
         在js中所以可以由我们自主命名的都叫标识符 例如:var a;这个a就是我们给它起的名字标识符
         变量名、函数名、属性名都属于标识符
         命名一个标识符时，需要遵守如下规则
           1.标识符中可以含有字母、数字、_、%、     例如: var s_1_$ = 123; console.log(s_1_$);
           2.标识符不能以数字开头
           3.标识符不能是JS中的关键字或保留字       例如:var var=123;
           4.标识符一般采用驼峰命名法
             首字母小写，后面每个单词的开头字母大写，其余字母小写 例如:helloWorld
         JS底层保存标识符时 实践上采用的是Unicode编码(UTF-8),所以理论上讲 所有的utf-8中所有的内容都可以作为标识符
      */
    </script>
    <script type="数据类型">
      /*
        *数据类型指的就是字面量的类型
        *在JS中一共有六种数据类型
          String 字符串
          Number 数值
          Boolean 布尔值
          Null 空值
          Undefined 未定义
          Object 对象
        *其中 String Number Boolean Null Undefined属于基本数据类型
          而Object属于引用数据类型
      */
      /*
        *String字符串
          在JS中字符串需要使用""引起来 var str="hello"; "hello"字符串赋值给了str这个变量 那么str它也是一个字符串
          使用单引号或双引号都可以，但是不要混着用
          引号不能嵌套 双引号里不能放双引号 同理，单引号里不能有单引号
          在字符串中我们可以使用\作为转义字符。 例如:\n表示换行。\t表示制表符，相当于按了个tab键。
      */
      /*
        *Number
          在JS中所有的数值都是Number类型，包括整数和浮点数(小数)

            var a = 123;
            var b = "123";

          JS中可以使用一个运算符 typeof 来检查一个变量的类型。语法:
            console.log(typeof a);表示检查a这个变量的类型并输出
            检查数值时，会返回Namber
            检查字符串时 会返回String

          JS中可以表示数字的最大值 Number.MAX_VALUE。语法:
            console.log(Number.MAX_VALUE);
            如果使用Number表示的数字超过了最大值，则会返回一个Infinity，表示正无穷。Infinity就是一个字面量，不需要加双引号。
              a = Infinity；
              console.log(typeof a);使用typeof检查Infinity也会返回Number

          JS中可以表示数字0以上的最小值 Number.MIN_VALUE。语法:
            console.log(Number.MIN_VALUE);
            大于0的最小正值

          NaN 是一个特殊的数字，表示Not a Namber
              a = NaN
              console.log(typeof a);使用typeof检查NaN也会返回number

          计算:
              var c = 123 + 456;
              console.log(c);
              把123+456的结果赋值给变量c
            在JS中整数的运算基本可以保证精确

              var c = 0.1 + 0.2;
            如果使用js进行浮点运算，可能得到的是一个不精确的结果,所以千万不要使用JS进行精确度要求比较高的运算。

        *Boolean布尔值
          布尔值只有两个，主要用来做逻辑判断
          true
            表示逻辑上的真
          false
            表示逻辑上的假
          var bool = true;
          console.log(bool);控制台显示为true
          console.log(typeof bool);使用typeof检查bool也会返回Boolean

        *Null空值
          Null的值只有一个，就是null
            null这个值专门来表示一个为空的对象
          var a = null;
          console.log(a);控制台显示为null
          console.log(typeof a);使用typeof检查null时会返回object，因为它专门来表示一个为空的对象

        *Undefined 未定义
          Undefined的值也是只有一个，就是undefined
            当我们声明一个变量，但不给变量赋值时，它的值就是undefined
          var b;
          console.log(b);控制台显示为undefined
          console.log(typeof b);使用typeof检查undefined时会返回undefined
      */
    </script>
    <script id="强制类型转换">
      /*
        *强制类型转换
          指的是讲一个数据类型强制转换为其他数据类型
            类型转换主要指，将其它类型转换为String Number Boolean

        *将其它数据类型转换为String
          方式一:
                调用被转换数据类型的toString()方法。
                该方法不会影响到源变量，它会将转换的结果返回
                但是注意：null和undefined这两个值没有toString()方法。如果调用它俩，会报错。
          方式二:
                调用String()函数，并将被转换的数据作为参数传递给函数
                使用String()函数做强制类型转换时，对于number和boolean实际上调用的就是toString()方法
                  但是对于null和undefined，就不会调用toString()方法。它会将字面量的null直接转换为字符号的"null",会将字面量的undefined直接转换为字符号的"undefined"


          var a = 123;
          console.log(typeof a); 输出类型为Number
          console.log(a);        输出值为123

          (1)调用a的toString方法:
            a = a.toString();    强制类型转换为String了
          (2)调用String()函数，来将A转换成字符串
            a = String(a)            转谁就把谁放到括号里，那括号里的a就叫参数。a作为参数传到我们的括号里，表示我们要把a转换成字符串。

        *将其它数据类型转换为Number
          方式一：
                使用Number()函数
                  字符串转数字
                    如果是纯数字的字符串，则直接转换成数字
                    如果字符串中有非数字的内容，则转换成NaN
                    如果字符串是个空串或者是全是空格的字符串""，则转成0
                  布尔转数字
                    true转成1
                    false转成0
                  null转数字 转成0
                  undefined转数字 转成NAN
          方式二：
                这种方式专门对付字符串
                parseInt() 把一个字符串转换成一个整数。
                parseFloat() 把一个字符串转换成一个浮点数。
                如果对非String使用parseInt()或parseFloat()，它会先将其转换成String再操作，有时可以利用这一点间接的对浮点数parseInt()取整

          var a = "123";
          console.log(typeof a); 输出类型为String
          console.log(a);        输出值为"123"

          (1)调用Number()函数，来将A转换成Number
            a = Number(a)

          var a = "123px";
          (2)调用parseInt()函数，把一个字符串转换成一个整数
            a = parseInt()    parseInt()可以将一个字符串中的有效的整数内容取出来，然后转换成Number
          var a = "123.456px";
          (2)调用parseFloat()函数，把一个字符串转换成一个浮点数。
            a = parseFloat()  parseFloat()可以将一个字符串中的有效的浮点数内容取出来，然后转换成Number

        *将其它数据类型转换为Boolean
          方式一：
                使用Boolean()函数
                  数字转布尔
                    除了0和NAN，其余的则都是直接转换成true
                  字符串转布尔
                    除了空串，其余的则都是直接转换成true
                  null和undefined转布尔
                    都会转换为false
                  对象转布尔
                    也会转换为true

          var a = 123;
          console.log(typeof a); 输出类型为Number
          console.log(a);        输出值为"123"

          (1)调用Boolean()函数，来讲a转为布尔值
            a = Boolean(a)       显示为true
      */
    </script>
    <script id="算数运算符">
      /*
        *运算符(也叫操作符)
          通过运算符可以对一个值或多个值进行运算，并获取运算结果
            例如:typeof就是一个运算符，可以获得一个值的类型
              它会讲该值的类型以字符串的形式返回
              number  string  boolean  undefined  object
            var a = 123
            var result = typeof a; 声明了result这个变量，result这个变量接收typeof这个运算符的运算结果
            console.log(result)
            console.log(typeof a)

        *算数运算符
          当对非number类型的值进行运算时，会将这些值转换为number，然后再运算.
            任何数和NaN做结果都是NaN

          + 可以对两个值进行加法进行运算，并将结果返回
              如果对两个字符串进行加法运算，则会做拼串。什么时拼串？(会将两个字符串拼接成一个字符串，并返回)
                result = "123" + "456"; 结果为123456
                result = "你好" + "大帅哥"; 结果为你好大帅哥
                result str = "锄禾日当午，" +
                             "汗滴禾下土，" +
                             "谁知盘中餐，" +
                             "粒粒皆辛苦";多字符串换行以后 后面添加+ 拼到一起成为一行里的四句
            任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
                result = 123 + "1"; 结果为1231
                result = true + "hello"; 结果为truehello
              我们可以利用这一点，来将任意类型的数据转换为String。只需要为任意的数据类型做+ ""即可将其转换为String
              这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数
                var c = 123
                c = c + ""
                console.log(c)
                控制台输出的结果是123，那它是谁的值呢我看不出来，所以我希望不仅输出的结果是123，还希望告诉我这个123是谁的值。所以我们经常采用这样一种写法
                console.log("c = "+c)


            result = true + 1; 结果为2
            result = true + false;  结果为1
            result = 2 + null; 结果为2
            result = 2 + NaN;
            result = 1 + 2 + "3"; 结果为33
            result = "3" + 1 + 2; 结果为312

          - 可以对两个值进行加法运算，并将结果返回
            result = 100 - "3"; 结果为97，和100 - 3是一样的。所以注意，只有字符串的+法这种特殊情况转String，其余的运算符对字符串进行运算时都是转成Number
          * 可以对两个值进行乘法运算
          / 可以对两个值进行除法运算
            任何值做 - * / 运算时都会转换成number
              我们可以利用这一特点做隐式的类型转换
                可以通过一个值 -0 *1 /1 来将其转换为number。原理和Number()函数一样，使用起来更加简单
                var d = "123"
                d = d - 0

          % 取模运算(取余数)
            result = 9 % 3; 9和3相除，取余数。9除3等于3，余数为0。结果为0
            result = 9 % 4; 9和4相除，取余数。9除4等于2，余数为1。结果为1
            result = 9 % 5; 9和5相除，取余数。9除5等于1，余数为4。结果为4
      */
    </script>
    <script id="一元运算符">
      /*
        *一元运算符,只需要一个操作数。(什么时操作数？1 + 1 就是两个操作数)
          +正号
            正号不会对数值产生影响
              var a = 123
              a = +a
              console.log("a = "+a) 控制台输出结果还是123
          -负号
            负号可以对数字进行符号的取反

            对于非number类型的值
              它会将会先转换为number,然后再运算
                a = true true转换成number为1
                a = -a   结果为-1
              可以对任意的的数据类型使用+ ，来将其转换为Number
              它的原理和number()函数一样
                a = "18"
                a = +a

                var result = 1 + "2" + 3        结果为字符串123
                console.log("result = "+result) 控制台结果为数值123

                var result = 1 + +"2" + 3       结果为数值6
                console.log("result = "+result)
      */
    </script>
    <script id="自增和自减 ">
      /*
        *自增
          通过自增可以使变量在自身的基础上增加1
            var a = 1
            a = a + 1;
            console.log(a) 控制台输出结果为2
          对于一个变量自增后，原变量的值会立即自增1
            var a = 1
            a++;//使a自身增1,后每调一次自身增1
            a++;
            a++;
            a++;
            console.log(a) 控制台输出结果为5
          自增分为两种:后++(a++) 前++(++a)
            无论是a++ 还是++a,都会立即使原变量a的值+1，这两种自增方式对于原变量a来说是没有任何区别的
            不同的是a++ 和 ++a的值不同
              a++的值等于原变量的值(自增前的值)
                var a = 1
                console.log(a++)       a++它是表达式的值 控制台结果为1
                console.log("a = "+a)  a它是变量的值     控制台结果为2
              ++a的值等于原变量自增后的值
                var a = 1
                console.log(++a)       控制台结果为2
                console.log("a = "+a)  控制台结果为2

              var c = 10
              c++                      第一次c++,是在10的基础上自增
              console.log(c++)         第二次c++,是在11的基础上自增，所以控制台结果为11

              var d = 20
              ++c                      ++d是新值，第一次自增是在20的基础上自增 自增后变成21
              console.log(++c)         第二次自增是在21的基础上自增，控制台结果为22

              var d = 20
              var resulst = d++ + ++d + d
                          //20 + 22 + 22
              console.log("resulst = "+resulst) 结果为64

        *自减
            通过自增可以使变量在自身的基础上减1
              var num = 10
              num--
              console.log("num = "+num)   控制台结果为9

              var num = 10
              --num
              console.log("num = "+num)   控制台结果为9
          自增分为两种:后--(a--) 前--(--a)
            不论是a--还是--a，都会立即使原变量的值自减1
            不同的是a-- 和 --a的值不同
              var num = 10
                a--的值等于原变量的值(自减前的值)
                  console.log(num--)        num--它是表达式的值 控制台结果为10
                  console.log("num = "+num) num它是变量的值     控制台结果为9
                --a的值等于原变量自减后的值
                  console.log(--num)        控制台结果为9
                  console.log("num = "+num) 控制台结果为9
      */
      /*
        *练习
        var n1 = 10, n2 = 20;
        var n = n1++;
        console.log("n = "+n);        10
        console.log("n = "+n1);       11
        n = ++n1
        console.log("n = "+n);        12
        console.log("n1 = "+n1);      12
        n = n2--
        console.log("n = "+n);        20
        console.log("n2 = "+n2);      19
        n = --n2
        console.log("n = "+n);        18
        console.log("n2 = "+n2)       18
      */
    </script>
    <script id="逻辑运算符">
      /*
        *JS中为我们提供了三种逻辑运算符
        * ! 非 可以用来对一个值进行非运算
            所谓非运算就是指对一个布尔值进行取反操作，true变false，false变true
              var a = true;
              a = !a
              console.log("a = "+a)    控制台结果为a=false

              var a = false;
              a = !a;
              console.log("a = "+a)    控制台结果为a=true
            如果对一个值进行两次取反，它不会变化，还是那个值
            如果对非布尔值进行运算，则会将其先转换成布尔值，然后取反
              var b = 10               对非布尔值取反先将非布尔值转换成Boolean true
              b = !b;                  再取反
              console.log("a = "+b)    控制台结果为false
            所以我们可以利用该特点，将一个任意的数据类型 取两次反，来将其转换成Boolean。原理和Boolean()函数一样。
              var b = 10               对非布尔值取反先将非布尔值转换成Boolean true
              b = !！b;                对一个值进行两次取反，它不会变化，还是那个值
              console.log("a = "+b)    控制台结果为true
        * && 与 可以对&&符号两侧的值进行与运算 并返回结果
            运算规则
            两个值中只要有一个值是false,就返回false.只有两个值都是true时，才会返回true
              只要有一个值都是false,就返回false
                var result = true && false
                console.log("result ="+result)  运算结果为result=false

              如果两个值都是true,则返回第二个true
                var result = true && true
                console.log("result ="+result)  运算结果为result=true

            JS中的"与"属于短路的与，如果第一个值为false，则不会看第二个值(因为我已经判断出结果了)
              第一个值为true，会检查第二个值
              true && alert("看我出不出来");     弹窗出来

              第一个值为false，不会检查第二个值
              false && alert("看我出不出来");    弹窗没有出来
        * || 或 可以对||符号两侧的值进行与运算 并返回结果
            运算规则
            两个值中只要有一个值是true,就返回true.只有两个值都是false时，才会返回false
              只要有一个值都是true,就返回true
                var result = false || true
                console.log("result ="+result)      运算结果为result=true
                var result = true || false
                console.log("result ="+result)      运算结果为result=true
                var result = true || true
                console.log("result ="+result)      运算结果为result=true

              如果两个值都是false,则返回false
                var result = false || false
                console.log("result ="+result)      运算结果为result=false
            JS中的"或"属于短路的或，如果第一个值为true，则不会看第二个值(因为我已经判断出结果了)
              第一个值为false，会检查第二个值
              false && alert("看我出不出来");        弹窗出来
              第一个值为true，不会检查第二个值
              true && alert("看我出不出来");         弹窗没有出来
      */
    </script>
    <script id="非布尔值的与或运算">
      /*
       *  && || 非布尔值的情况
            对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算,并且返回原值
            与运算
              如果第一个值为true,则必然返回第二个值
              如果第一个值为false,则直接返回第一个值

              与运算，如果两边都是true，则返回后面的
                var result = 1 && 2                  转换为布尔值true && true,那返回1还是返回2呢？
                console.log("result = "+result)      运算结果为2
                var result = 2 && 1                  转换为布尔值true && true,那返回1还是返回2呢？
                console.log("result = "+result)      运算结果为1

              与运算，只要有一个值都是false,就返回false
                var result = 0 && 2                  转换为布尔值false && true  与运算，只要有一个值都是false,就返回false
                console.log("result = "+result)      运算结果为0
                var result = 2 && 0                  转换为布尔值true && false
                console.log("result = "+result)      运算结果为0
              与运算，如果两边都是false，则返回前面的
                var result = NaN && 0                  转换为布尔值false && false,那返回哪个false呢？
                console.log("result = "+result)      运算结果为NaN
                var result = 0 && NaN                  转换为布尔值false && false,那返回哪个false呢？
                console.log("result = "+result)      运算结果为0
            或运算
              如果第一个值为true,则直接返回第一个值
                var result = 1 || 2                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为1
                var result = 2 || NaN                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为2

              如果第一个值为false,则直接返回第二个值
                var result = 0 || 2                  转换为布尔值false || true
                console.log("result = "+result)      运算结果为2
                var result = NaN || 0                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为0

                var result = "" || "hello"           转换为布尔值第一个空串为false
                console.log("result = "+result)      运算结果为hello
                var result = -1 || "hello"           转换为布尔值第一个值为true
                console.log("result = "+result)      运算结果为-1
      */
    </script>
    <script id="赋值运算符">
      /*
       * = 可以将符号右侧的值赋值给符号左侧的变量
          var a = 123
          console.log(a)            控制台结果为123

         += a += 5等价于a = a + 5
          var a = 10
          a = a + 5可以写成a += 5
          console.log("a = "+a)            控制台结果为a = 15

         -= a -= 5等价于a = a - 5
          var a = 10
          a = a - 5可以写成a -= 5
          console.log("a = "+a)            控制台结果为a = 5

         *= a *= 5等价于a = a * 5
          var a = 10
          a = a * 5可以写成a *= 5
          console.log("a = "+a)            控制台结果为a = 50

         /= a /= 5等价于a = a / 5
          var a = 10
          a = a / 5可以写成a /= 5
          console.log("a = "+a)            控制台结果为a = 2

         %= a %= 5等价于a = a % 5
          var a = 10
          a = a % 5可以写成a %= 5
          console.log("a = "+a)            控制台结果为a = 0
      */
    </script>
    <script id="关系运算符">
      /*
       *  通过关系运算符可以比较两个值之间的大小关系
            如果关系成立会返回true,如果关系不成立则返回false

          >大于号
            判断符号左侧的值是否大于右侧的
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 > 10                   关系不成立
            console.log("result = "+result)       控制台结果为false

            var result = 5 > 4                    关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 > 5                    关系不成立
            console.log("result = "+result)       控制台结果为false

          >=大于等于
            判断符号左侧的值是否大于或等于
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 >=  5                    关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 >=  4                    关系成立
            console.log("result = "+result)       控制台结果为true

          <小于号
            判断符号左侧的值是否小于右侧的
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 < 10                   关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 < 4                    关系不成立
            console.log("result = "+result)       控制台结果为false

          <小于等于
            判断符号左侧的值是否小于或等于
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 <=  5                  关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 <=  4                  关系不成立
            console.log("result = "+result)       控制台结果为false

          非数值的情况
          对于非数值进行比较时，会将其转换为数值，然后再比较
            console.log(1 > true)                  控制台结果为false
            console.log(1 >= true)                 控制台结果为true
            console.log(1 > "0")                   控制台结果为true
            console.log(10 > null)                 控制台结果为true
            console.log(true > false)              控制台结果为true

            任何值和NaN做比较都是false
            console.log(10 > "hello")      hello转换为数字是NaN       控制台结果为false
            console.log(10 > "undefined")  undefined转换为数字是NaN   控制台结果为false

            如果符号两侧的值都是字符串，不会将其转换成数字将其比较，而会分别比较字符串中字符的Unicode编码
            console.log("1" < "5")       Unicode编码0031<0035         控制台结果为true
            console.log("11" < "5")                  控制台结果为true
            console.log("a" < "b")                   控制台结果为true

            比较字符编码时是一位一位进行比较的，第一位a小于b，后面的bc就不比了，直接返回结果true
            console.log("abc" < "b")                 控制台结果为true
            console.log("11" < "5")      Unicode编码0031,0031<0035    控制台结果为true

            比较字符编码时是一位一位进行比较的，如果两位一样，则比较下一位(所以可以借用它来进行英文排序)
            console.log("bbc" < "b")                 控制台结果为false

            如果比较的两个字符串型的数字，可能会得到不可预期的结果
            所以注意，在比较两个字符串型的数字时，一定一定要转型
            console.log("1258965445687542" < +"5")   控制台结果为false
      */
    </script>
    <script id="相等运算符">
      /*
       *  相等运算符用来比较两个值是否相等，如果相等会返回true，否则会返回false
          使用==来做相等运算
          console.log(1 == 1)      控制台结果为true

          var a = 10
          console.log(a == 4)      控制台结果为false

          当使用==比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后再比较
          console.log("1" == 1)      控制台结果为true
          console.log("true" == "1") 控制台结果为true

          也有一个特殊情况null == 0 ,null没有转换为number
          console.log(null == 0)     控制台结果为false
      */
      /*
       *  undefined衍生自null
            所以这两个值做相等判断时，会返回true
            console.log(undefined == null)      控制台结果为true
      */
      /*
       *  NaN不和任何值相等，包括它本身
          console.log(NaN == NaN)      控制台结果为false

          var b = NaN (那我现在想判断b的值是否时NaN)
          console.log(NaN == NaN)      控制台结果为false，这个方法不行

          我们可以通过isNaN()函数来判断一个值是否时NaN
          如果该值时NaN，则返回true，否则返回false
          var b = NaN
          console.log(isNaN(b))        控制台结果为true
      */
      /*  不相等
       *  不相等运算符用来比较两个值是否不相等，如果不相等会返回true，否则会返回false
          使用!=来做不相等运算
          console.log(10 != 5)      控制台结果为true

          var a = 10
          console.log(10 != 10)      控制台结果为false

          console.log("abcd" != "abcd")      控制台结果为false

          !=也会对变量进行自动的类型转换，如果转换后相等，它会返回false
          console.log("1" != 1)      控制台结果为false
      */
      /*  全等
          判断两个值是否全等，它和相等类似，不同的是它不会做类型的自动转换
            如果两个值的类型不同，直接返回false
          使用===来做相等运算
          console.log("123" === 123)      控制台结果为false
          console.log(undefined === null)      控制台结果为false
      */
      /*  不全等
          判断两个值是否不全等，它和不等类似，不同的是它不会做类型的自动转换
            如果两个值的类型不同，直接返回true
          使用!==来做相等运算
          console.log("123" === 123)      控制台结果为true
      */
    </script>
    <script id="条件运算符">
      /*  条件运算符也叫三元运算符
            语法：
                条件表达式?语句1:语句2
              执行流程：
                      条件运算符在执行时，首先对条件表达式进行求值，
                        如果该值为true，则执行语句1，并返回执行结果
                        如果该值为false，则执行语句2，并返回执行结果

              true?alert("语句1"):alert("语句2")  执行结果为语句1
              false?alert("语句1"):alert("语句2")  执行结果为语句2

              var a = 10
              var b = 20
              a > b ?alert("a大"):alert("b大")  执行结果为b大
              var a = 30
              var b = 20
              a > b ?alert("a大"):alert("b大")  执行结果为a大

                        如果条件表达式的求值结果是一个非布尔值
                            会将其转换为布尔值，然后再进行运算

              "hello"?alert("语句1"):alert("语句2")  执行结果为语句1
              ""?alert("语句1"):alert("语句2")       执行结果为语句2

              获取a 和 b中的最大值
              var a = 10
              var b = 20
              var c = 40
              var max = a > b ? a : b;  (我要判断a是否大于b 如果a大于b我执行a，把变量a赋值给max.如果a小于b我执行b，把b赋值给max.最后max就是谁大就是谁)
              console.log("max = "+max)

              获取a b c中的最大值
              (接上一步接着比较最终得出结果)var max = max > c ? max : c  (我再拿max和c比，如果max大返回max，如果c大，那么c赋值给max)

              (一步到位获取a b c中的最大值)  //这种写法不推荐使用，不方便阅读
              var a = 10
              var b = 20
              var c = 40
              var max = a > b ? (a > c ? a : c) : (b > c ? b : c)     (如果a大于b则a大，a大执行第一个表达式 比较a和c谁大，如果a比c大那么a就是最大的了，如果a比c小那么c就是最大的了)
                                                                      (如果a大于b不成立，那就执行第二个表达式 比较b和c谁大，如果b比c大那么b就是最大的了，如果b比c小那么c就是最大的了)
              console.log("max = "+max)
      */
    </script>
    <script id="逗号运算符">
      /*  , 使用可以分割多个语句，一半可以在声明多个变量时使用
            var a;
            var b;
            var c;
          使用,运算符同时声明多个变量
            var a , b , c;
          可以声明多个变量并赋值
            var a = 1 , b = 2 , c = 3;
      */
    </script>
    <script id="运算符的优先级">
      /*  就和数学中一样，在JS中也有优先级，
          比如：先乘除 后加减

          var result = 1 + 2 * 3   结果为7

          如果||的优先级高，或者两个一样高(应从左往右算) 第一个为true就不看第二个了，1&&3，第一个true返回第二个 返回3
          如果&&的优先级高，那么先算2 && 3，第一个true返回第二个 返回3，1 || 3 第一个为true就不看第二个了 返回1
          var result = 1 || 2 && 3
          console.log("result = "+result) 控制台结果为result = 1 所以&&的优先级高

          在JS中有一个运算符优先级的表
            在表中越靠上优先级越高，优先级越高越优先计算
            如果优先级一样，则从左往右计算
          但是这个表我们并不需要记忆，如果遇到优先级不清楚
            可以使用()来改变优先级

          var result = (1 || 2) && 3        控制台结果为3
      */

    </script>


  <!-- </head> -->
  <body>
    <!-- 可以将js代码编写到标签的onclick属性中
    虽然可以写在标签的属性中，但是它们属于结构与行为偶合，不方便我们维护-->
      <!-- <button onclick="alert('讨厌，你点我干嘛~~');">点我一下</button> -->
    <!-- 当我们点击按钮时，js代码才会执行 -->

    <!-- 可以将js代码写在超链接href属性中 -->
      <!-- <a href="javascript:alert('让你点你就点~');">你也点我一下</a> -->
    <!-- 当我们点击超链接时，会执行我们的js代码 -->
      <!-- <a href="javascript:;">你也点我一下</a> -->
    <!-- 我们希望超链接点完没有反应，通过js处理一些功能 -->
  </body>
</html>
