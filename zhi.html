 <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script type="text/javascript" src=""></script>
    <script type="xxx">
      console.log(2021);
      console.log(2021 * 2);
      console.log(2021 * 2021);
      console.log(2021 * 2021 * 2021 * 2021 * 2021);
      console.log(201 > 50 && 2021 > 100);
      console.log(2021 % 2 == 1);
      console.log(2021 % 2 == 0);
      console.log(2021 % 10);
      console.log(2021 % 100);
      console.log(2021 > 200 && 2021 % 3 && 2021 % 7 != 0);
      console.log((1864 - (1864 % 100)) / 100 + 1);
    </script>
    <script type="">
      // 控制浏览器弹出一个警告框
      alert("这是我的第一行js代码");
      // 输出在浏览器窗口

      // 让计算机在页面中输出一个内容
      // document(文档的意思，一个网页就是一个文档)

      document.write("写一个文档 看我出不出来");
      // 输出在在body 页面中

      // 向控制台输出一个内容
      console.log("你猜我在哪儿出来呢？");
      // 输出在控制台

      // js代码指令是从上到下一条一条执行的;
      alert("这是我的第一行代码");
      document.write("写一个文档 看我出不出来");
      console.log("你猜我在哪儿出来呢？");
      // 以上三个都是输出语句
    </script>
    <script type="字面量和变量">
      /*
        字面量 都是一些不可改变的值 例如:1 2 3 4 5 6
        字面量都是可以直接使用的,但是我们一半不会直接使用字面量

        *变量 可以保存我们的字面量 例如:x=1;
        而且变量的值是可以任意改变的，变量更加方便我们使用，所以在开发中都是通过变量去保存一个字面量
        变量还可以对字面量进行描述 例如 age=80;

        *声明变量
        在js中使用var关键字来声明一个变量 例如:var a;

        *为变量赋值
        a=123;

        *声明变量和赋值同时进行
        var age = 80;
        age = 81;(赋值后面的这个有效)
        console.log(age)
      */
    </script>
    <script type="标识符">
      /*
        *标识符
         在js中所以可以由我们自主命名的都叫标识符 例如:var a;这个a就是我们给它起的名字标识符
         变量名、函数名、属性名都属于标识符
         命名一个标识符时，需要遵守如下规则
           1.标识符中可以含有字母、数字、_、%、     例如: var s_1_$ = 123; console.log(s_1_$);
           2.标识符不能以数字开头
           3.标识符不能是JS中的关键字或保留字       例如:var var=123;
           4.标识符一般采用驼峰命名法
             首字母小写，后面每个单词的开头字母大写，其余字母小写 例如:helloWorld
         JS底层保存标识符时 实践上采用的是Unicode编码(UTF-8),所以理论上讲 所有的utf-8中所有的内容都可以作为标识符
      */
    </script>
    <script type="数据类型">
      /*
        *数据类型指的就是字面量的类型
        *在JS中一共有六种数据类型
          String 字符串
          Number 数值
          Boolean 布尔值
          Null 空值
          Undefined 未定义
          Object 对象
        *其中 String Number Boolean Null Undefined属于基本数据类型
          而Object属于引用数据类型
      */
      /*
        *String字符串
          在JS中字符串需要使用""引起来 var str="hello"; "hello"字符串赋值给了str这个变量 那么str它也是一个字符串
          使用单引号或双引号都可以，但是不要混着用
          引号不能嵌套 双引号里不能放双引号 同理，单引号里不能有单引号
          在字符串中我们可以使用\作为转义字符。 例如:\n表示换行。\t表示制表符，相当于按了个tab键。
      */
      /*
        *Number
          在JS中所有的数值都是Number类型，包括整数和浮点数(小数)

            var a = 123;
            var b = "123";

          JS中可以使用一个运算符 typeof 来检查一个变量的类型。语法:
            console.log(typeof a);表示检查a这个变量的类型并输出
            检查数值时，会返回Namber
            检查字符串时 会返回String

          JS中可以表示数字的最大值 Number.MAX_VALUE。语法:
            console.log(Number.MAX_VALUE);
            如果使用Number表示的数字超过了最大值，则会返回一个Infinity，表示正无穷。Infinity就是一个字面量，不需要加双引号。
              a = Infinity；
              console.log(typeof a);使用typeof检查Infinity也会返回Number

          JS中可以表示数字0以上的最小值 Number.MIN_VALUE。语法:
            console.log(Number.MIN_VALUE);
            大于0的最小正值

          NaN 是一个特殊的数字，表示Not a Namber
              a = NaN
              console.log(typeof a);使用typeof检查NaN也会返回number

          计算:
              var c = 123 + 456;
              console.log(c);
              把123+456的结果赋值给变量c
            在JS中整数的运算基本可以保证精确

              var c = 0.1 + 0.2;
            如果使用js进行浮点运算，可能得到的是一个不精确的结果,所以千万不要使用JS进行精确度要求比较高的运算。

        *Boolean布尔值
          布尔值只有两个，主要用来做逻辑判断
          true
            表示逻辑上的真
          false
            表示逻辑上的假
          var bool = true;
          console.log(bool);控制台显示为true
          console.log(typeof bool);使用typeof检查bool也会返回Boolean

        *Null空值
          Null的值只有一个，就是null
            null这个值专门来表示一个为空的对象
          var a = null;
          console.log(a);控制台显示为null
          console.log(typeof a);使用typeof检查null时会返回object，因为它专门来表示一个为空的对象

        *Undefined 未定义
          Undefined的值也是只有一个，就是undefined
            当我们声明一个变量，但不给变量赋值时，它的值就是undefined
          var b;
          console.log(b);控制台显示为undefined
          console.log(typeof b);使用typeof检查undefined时会返回undefined
      */
    </script>
    <script id="强制类型转换">
      /*
        *强制类型转换
          指的是讲一个数据类型强制转换为其他数据类型
            类型转换主要指，将其它类型转换为String Number Boolean

        *将其它数据类型转换为String
          方式一:
                调用被转换数据类型的toString()方法。
                该方法不会影响到源变量，它会将转换的结果返回
                但是注意：null和undefined这两个值没有toString()方法。如果调用它俩，会报错。
          方式二:
                调用String()函数，并将被转换的数据作为参数传递给函数
                使用String()函数做强制类型转换时，对于number和boolean实际上调用的就是toString()方法
                  但是对于null和undefined，就不会调用toString()方法。它会将字面量的null直接转换为字符号的"null",会将字面量的undefined直接转换为字符号的"undefined"


          var a = 123;
          console.log(typeof a); 输出类型为Number
          console.log(a);        输出值为123

          (1)调用a的toString方法:
            a = a.toString();    强制类型转换为String了
          (2)调用String()函数，来将A转换成字符串
            a = String(a)            转谁就把谁放到括号里，那括号里的a就叫参数。a作为参数传到我们的括号里，表示我们要把a转换成字符串。

        *将其它数据类型转换为Number
          方式一：
                使用Number()函数
                  字符串转数字
                    如果是纯数字的字符串，则直接转换成数字
                    如果字符串中有非数字的内容，则转换成NaN
                    如果字符串是个空串或者是全是空格的字符串""，则转成0
                  布尔转数字
                    true转成1
                    false转成0
                  null转数字 转成0
                  undefined转数字 转成NAN
          方式二：
                这种方式专门对付字符串
                parseInt() 把一个字符串转换成一个整数。
                parseFloat() 把一个字符串转换成一个浮点数。
                如果对非String使用parseInt()或parseFloat()，它会先将其转换成String再操作，有时可以利用这一点间接的对浮点数parseInt()取整

          var a = "123";
          console.log(typeof a); 输出类型为String
          console.log(a);        输出值为"123"

          (1)调用Number()函数，来将A转换成Number
            a = Number(a)

          var a = "123px";
          (2)调用parseInt()函数，把一个字符串转换成一个整数
            a = parseInt()    parseInt()可以将一个字符串中的有效的整数内容取出来，然后转换成Number
          var a = "123.456px";
          (2)调用parseFloat()函数，把一个字符串转换成一个浮点数。
            a = parseFloat()  parseFloat()可以将一个字符串中的有效的浮点数内容取出来，然后转换成Number

        *将其它数据类型转换为Boolean
          方式一：
                使用Boolean()函数
                  数字转布尔
                    除了0和NAN，其余的则都是直接转换成true
                  字符串转布尔
                    除了空串，其余的则都是直接转换成true
                  null和undefined转布尔
                    都会转换为false
                  对象转布尔
                    也会转换为true

          var a = 123;
          console.log(typeof a); 输出类型为Number
          console.log(a);        输出值为"123"

          (1)调用Boolean()函数，来讲a转为布尔值
            a = Boolean(a)       显示为true
      */
    </script>
    <script id="算数运算符">
      /*
        *运算符(也叫操作符)
          通过运算符可以对一个值或多个值进行运算，并获取运算结果
            例如:typeof就是一个运算符，可以获得一个值的类型
              它会讲该值的类型以字符串的形式返回
              number  string  boolean  undefined  object
            var a = 123
            var result = typeof a; 声明了result这个变量，result这个变量接收typeof这个运算符的运算结果
            console.log(result)
            console.log(typeof a)

        *算数运算符
          当对非number类型的值进行运算时，会将这些值转换为number，然后再运算.
            任何数和NaN做结果都是NaN

          + 可以对两个值进行加法进行运算，并将结果返回
              如果对两个字符串进行加法运算，则会做拼串。什么时拼串？(会将两个字符串拼接成一个字符串，并返回)
                result = "123" + "456"; 结果为123456
                result = "你好" + "大帅哥"; 结果为你好大帅哥
                result str = "锄禾日当午，" +
                             "汗滴禾下土，" +
                             "谁知盘中餐，" +
                             "粒粒皆辛苦";多字符串换行以后 后面添加+ 拼到一起成为一行里的四句
            任何的值和字符串做加法运算，都会先转换为字符串，然后再和字符串做拼串的操作
                result = 123 + "1"; 结果为1231
                result = true + "hello"; 结果为truehello
              我们可以利用这一点，来将任意类型的数据转换为String。只需要为任意的数据类型做+ ""即可将其转换为String
              这是一种隐式的类型转换，由浏览器自动完成，实际上它也是调用String()函数
                var c = 123
                c = c + ""
                console.log(c)
                控制台输出的结果是123，那它是谁的值呢我看不出来，所以我希望不仅输出的结果是123，还希望告诉我这个123是谁的值。所以我们经常采用这样一种写法
                console.log("c = "+c)


            result = true + 1; 结果为2
            result = true + false;  结果为1
            result = 2 + null; 结果为2
            result = 2 + NaN;
            result = 1 + 2 + "3"; 结果为33
            result = "3" + 1 + 2; 结果为312

          - 可以对两个值进行加法运算，并将结果返回
            result = 100 - "3"; 结果为97，和100 - 3是一样的。所以注意，只有字符串的+法这种特殊情况转String，其余的运算符对字符串进行运算时都是转成Number
          * 可以对两个值进行乘法运算
          / 可以对两个值进行除法运算
            任何值做 - * / 运算时都会转换成number
              我们可以利用这一特点做隐式的类型转换
                可以通过一个值 -0 *1 /1 来将其转换为number。原理和Number()函数一样，使用起来更加简单
                var d = "123"
                d = d - 0

          % 取模运算(取余数)
            result = 9 % 3; 9和3相除，取余数。9除3等于3，余数为0。结果为0
            result = 9 % 4; 9和4相除，取余数。9除4等于2，余数为1。结果为1
            result = 9 % 5; 9和5相除，取余数。9除5等于1，余数为4。结果为4
      */
    </script>
    <script id="一元运算符">
      /*
        *一元运算符,只需要一个操作数。(什么时操作数？1 + 1 就是两个操作数)
          +正号
            正号不会对数值产生影响
              var a = 123
              a = +a
              console.log("a = "+a) 控制台输出结果还是123
          -负号
            负号可以对数字进行符号的取反

            对于非number类型的值
              它会将会先转换为number,然后再运算
                a = true true转换成number为1
                a = -a   结果为-1
              可以对任意的的数据类型使用+ ，来将其转换为Number
              它的原理和number()函数一样
                a = "18"
                a = +a

                var result = 1 + "2" + 3        结果为字符串123
                console.log("result = "+result) 控制台结果为数值123

                var result = 1 + +"2" + 3       结果为数值6
                console.log("result = "+result)
      */
    </script>
    <script id="自增和自减 ">
      /*
        *自增
          通过自增可以使变量在自身的基础上增加1
            var a = 1
            a = a + 1;
            console.log(a) 控制台输出结果为2
          对于一个变量自增后，原变量的值会立即自增1
            var a = 1
            a++;//使a自身增1,后每调一次自身增1
            a++;
            a++;
            a++;
            console.log(a) 控制台输出结果为5
          自增分为两种:后++(a++) 前++(++a)
            无论是a++ 还是++a,都会立即使原变量a的值+1，这两种自增方式对于原变量a来说是没有任何区别的
            不同的是a++ 和 ++a的值不同
              a++的值等于原变量的值(自增前的值)
                var a = 1
                console.log(a++)       a++它是表达式的值 控制台结果为1
                console.log("a = "+a)  a它是变量的值     控制台结果为2
              ++a的值等于原变量自增后的值
                var a = 1
                console.log(++a)       控制台结果为2
                console.log("a = "+a)  控制台结果为2

              var c = 10
              c++                      第一次c++,是在10的基础上自增
              console.log(c++)         第二次c++,是在11的基础上自增，所以控制台结果为11

              var d = 20
              ++c                      ++d是新值，第一次自增是在20的基础上自增 自增后变成21
              console.log(++c)         第二次自增是在21的基础上自增，控制台结果为22

              var d = 20
              var resulst = d++ + ++d + d
                          //20 + 22 + 22
              console.log("resulst = "+resulst) 结果为64

        *自减
            通过自增可以使变量在自身的基础上减1
              var num = 10
              num--
              console.log("num = "+num)   控制台结果为9

              var num = 10
              --num
              console.log("num = "+num)   控制台结果为9
          自增分为两种:后--(a--) 前--(--a)
            不论是a--还是--a，都会立即使原变量的值自减1
            不同的是a-- 和 --a的值不同
              var num = 10
                a--的值等于原变量的值(自减前的值)
                  console.log(num--)        num--它是表达式的值 控制台结果为10
                  console.log("num = "+num) num它是变量的值     控制台结果为9
                --a的值等于原变量自减后的值
                  console.log(--num)        控制台结果为9
                  console.log("num = "+num) 控制台结果为9
      */
      /*
        *练习
        var n1 = 10, n2 = 20;
        var n = n1++;
        console.log("n = "+n);        10
        console.log("n = "+n1);       11
        n = ++n1
        console.log("n = "+n);        12
        console.log("n1 = "+n1);      12
        n = n2--
        console.log("n = "+n);        20
        console.log("n2 = "+n2);      19
        n = --n2
        console.log("n = "+n);        18
        console.log("n2 = "+n2)       18
      */
    </script>
    <script id="逻辑运算符">
      /*
        *JS中为我们提供了三种逻辑运算符
        * ! 非 可以用来对一个值进行非运算
            所谓非运算就是指对一个布尔值进行取反操作，true变false，false变true
              var a = true;
              a = !a
              console.log("a = "+a)    控制台结果为a=false

              var a = false;
              a = !a;
              console.log("a = "+a)    控制台结果为a=true
            如果对一个值进行两次取反，它不会变化，还是那个值
            如果对非布尔值进行运算，则会将其先转换成布尔值，然后取反
              var b = 10               对非布尔值取反先将非布尔值转换成Boolean true
              b = !b;                  再取反
              console.log("a = "+b)    控制台结果为false
            所以我们可以利用该特点，将一个任意的数据类型 取两次反，来将其转换成Boolean。原理和Boolean()函数一样。
              var b = 10               对非布尔值取反先将非布尔值转换成Boolean true
              b = !！b;                对一个值进行两次取反，它不会变化，还是那个值
              console.log("a = "+b)    控制台结果为true
        * && 与 可以对&&符号两侧的值进行与运算 并返回结果
            运算规则
            两个值中只要有一个值是false,就返回false.只有两个值都是true时，才会返回true
              只要有一个值都是false,就返回false
                var result = true && false
                console.log("result ="+result)  运算结果为result=false

              如果两个值都是true,则返回第二个true
                var result = true && true
                console.log("result ="+result)  运算结果为result=true

            JS中的"与"属于短路的与，如果第一个值为false，则不会看第二个值(因为我已经判断出结果了)
              第一个值为true，会检查第二个值
              true && alert("看我出不出来");     弹窗出来

              第一个值为false，不会检查第二个值
              false && alert("看我出不出来");    弹窗没有出来
        * || 或 可以对||符号两侧的值进行与运算 并返回结果
            运算规则
            两个值中只要有一个值是true,就返回true.只有两个值都是false时，才会返回false
              只要有一个值都是true,就返回true
                var result = false || true
                console.log("result ="+result)      运算结果为result=true
                var result = true || false
                console.log("result ="+result)      运算结果为result=true
                var result = true || true
                console.log("result ="+result)      运算结果为result=true

              如果两个值都是false,则返回false
                var result = false || false
                console.log("result ="+result)      运算结果为result=false
            JS中的"或"属于短路的或，如果第一个值为true，则不会看第二个值(因为我已经判断出结果了)
              第一个值为false，会检查第二个值
              false && alert("看我出不出来");        弹窗出来
              第一个值为true，不会检查第二个值
              true && alert("看我出不出来");         弹窗没有出来
      */
    </script>
    <script id="非布尔值的与或运算">
      /*
       *  && || 非布尔值的情况
            对于非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算,并且返回原值
            与运算
              如果第一个值为true,则必然返回第二个值
              如果第一个值为false,则直接返回第一个值

              与运算，如果两边都是true，则返回后面的
                var result = 1 && 2                  转换为布尔值true && true,那返回1还是返回2呢？
                console.log("result = "+result)      运算结果为2
                var result = 2 && 1                  转换为布尔值true && true,那返回1还是返回2呢？
                console.log("result = "+result)      运算结果为1

              与运算，只要有一个值都是false,就返回false
                var result = 0 && 2                  转换为布尔值false && true  与运算，只要有一个值都是false,就返回false
                console.log("result = "+result)      运算结果为0
                var result = 2 && 0                  转换为布尔值true && false
                console.log("result = "+result)      运算结果为0
              与运算，如果两边都是false，则返回前面的
                var result = NaN && 0                  转换为布尔值false && false,那返回哪个false呢？
                console.log("result = "+result)      运算结果为NaN
                var result = 0 && NaN                  转换为布尔值false && false,那返回哪个false呢？
                console.log("result = "+result)      运算结果为0
            或运算
              如果第一个值为true,则直接返回第一个值
                var result = 1 || 2                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为1
                var result = 2 || NaN                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为2

              如果第一个值为false,则直接返回第二个值
                var result = 0 || 2                  转换为布尔值false || true
                console.log("result = "+result)      运算结果为2
                var result = NaN || 0                  转换为布尔值true || true
                console.log("result = "+result)      运算结果为0

                var result = "" || "hello"           转换为布尔值第一个空串为false
                console.log("result = "+result)      运算结果为hello
                var result = -1 || "hello"           转换为布尔值第一个值为true
                console.log("result = "+result)      运算结果为-1
      */
    </script>
    <script id="赋值运算符">
      /*
       * = 可以将符号右侧的值赋值给符号左侧的变量
          var a = 123
          console.log(a)            控制台结果为123

         += a += 5等价于a = a + 5
          var a = 10
          a = a + 5可以写成a += 5
          console.log("a = "+a)            控制台结果为a = 15

         -= a -= 5等价于a = a - 5
          var a = 10
          a = a - 5可以写成a -= 5
          console.log("a = "+a)            控制台结果为a = 5

         *= a *= 5等价于a = a * 5
          var a = 10
          a = a * 5可以写成a *= 5
          console.log("a = "+a)            控制台结果为a = 50

         /= a /= 5等价于a = a / 5
          var a = 10
          a = a / 5可以写成a /= 5
          console.log("a = "+a)            控制台结果为a = 2

         %= a %= 5等价于a = a % 5
          var a = 10
          a = a % 5可以写成a %= 5
          console.log("a = "+a)            控制台结果为a = 0
      */
    </script>
    <script id="关系运算符">
      /*
       *  通过关系运算符可以比较两个值之间的大小关系
            如果关系成立会返回true,如果关系不成立则返回false

          >大于号
            判断符号左侧的值是否大于右侧的
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 > 10                   关系不成立
            console.log("result = "+result)       控制台结果为false

            var result = 5 > 4                    关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 > 5                    关系不成立
            console.log("result = "+result)       控制台结果为false

          >=大于等于
            判断符号左侧的值是否大于或等于
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 >=  5                    关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 >=  4                    关系成立
            console.log("result = "+result)       控制台结果为true

          <小于号
            判断符号左侧的值是否小于右侧的
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 < 10                   关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 < 4                    关系不成立
            console.log("result = "+result)       控制台结果为false

          <小于等于
            判断符号左侧的值是否小于或等于
            如果关系成立，则返回true. 如果关系不成立，则返回false
            var result = 5 <=  5                  关系成立
            console.log("result = "+result)       控制台结果为true

            var result = 5 <=  4                  关系不成立
            console.log("result = "+result)       控制台结果为false

          非数值的情况
          对于非数值进行比较时，会将其转换为数值，然后再比较
            console.log(1 > true)                  控制台结果为false
            console.log(1 >= true)                 控制台结果为true
            console.log(1 > "0")                   控制台结果为true
            console.log(10 > null)                 控制台结果为true
            console.log(true > false)              控制台结果为true

            任何值和NaN做比较都是false
            console.log(10 > "hello")      hello转换为数字是NaN       控制台结果为false
            console.log(10 > "undefined")  undefined转换为数字是NaN   控制台结果为false

            如果符号两侧的值都是字符串，不会将其转换成数字将其比较，而会分别比较字符串中字符的Unicode编码
            console.log("1" < "5")       Unicode编码0031<0035         控制台结果为true
            console.log("11" < "5")                  控制台结果为true
            console.log("a" < "b")                   控制台结果为true

            比较字符编码时是一位一位进行比较的，第一位a小于b，后面的bc就不比了，直接返回结果true
            console.log("abc" < "b")                 控制台结果为true
            console.log("11" < "5")      Unicode编码0031,0031<0035    控制台结果为true

            比较字符编码时是一位一位进行比较的，如果两位一样，则比较下一位(所以可以借用它来进行英文排序)
            console.log("bbc" < "b")                 控制台结果为false

            如果比较的两个字符串型的数字，可能会得到不可预期的结果
            所以注意，在比较两个字符串型的数字时，一定一定要转型
            console.log("1258965445687542" < +"5")   控制台结果为false
      */
    </script>
    <script id="相等运算符">
      /*
       *  相等运算符用来比较两个值是否相等，如果相等会返回true，否则会返回false
          使用==来做相等运算
          console.log(1 == 1)      控制台结果为true

          var a = 10
          console.log(a == 4)      控制台结果为false

          当使用==比较两个值时，如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后再比较
          console.log("1" == 1)      控制台结果为true
          console.log("true" == "1") 控制台结果为true

          也有一个特殊情况null == 0 ,null没有转换为number
          console.log(null == 0)     控制台结果为false
      */
      /*
       *  undefined衍生自null
            所以这两个值做相等判断时，会返回true
            console.log(undefined == null)      控制台结果为true
      */
      /*
       *  NaN不和任何值相等，包括它本身
          console.log(NaN == NaN)      控制台结果为false

          var b = NaN (那我现在想判断b的值是否时NaN)
          console.log(NaN == NaN)      控制台结果为false，这个方法不行

          我们可以通过isNaN()函数来判断一个值是否时NaN
          如果该值时NaN，则返回true，否则返回false
          var b = NaN
          console.log(isNaN(b))        控制台结果为true
      */
      /*  不相等
       *  不相等运算符用来比较两个值是否不相等，如果不相等会返回true，否则会返回false
          使用!=来做不相等运算
          console.log(10 != 5)      控制台结果为true

          var a = 10
          console.log(10 != 10)      控制台结果为false

          console.log("abcd" != "abcd")      控制台结果为false

          !=也会对变量进行自动的类型转换，如果转换后相等，它会返回false
          console.log("1" != 1)      控制台结果为false
      */
      /*  全等
          判断两个值是否全等，它和相等类似，不同的是它不会做类型的自动转换
            如果两个值的类型不同，直接返回false
          使用===来做相等运算
          console.log("123" === 123)      控制台结果为false
          console.log(undefined === null)      控制台结果为false
      */
      /*  不全等
          判断两个值是否不全等，它和不等类似，不同的是它不会做类型的自动转换
            如果两个值的类型不同，直接返回true
          使用!==来做相等运算
          console.log("123" === 123)      控制台结果为true
      */
    </script>
    <script id="条件运算符">
      /*  条件运算符也叫三元运算符
            语法：
                条件表达式?语句1:语句2
              执行流程：
                      条件运算符在执行时，首先对条件表达式进行求值，
                        如果该值为true，则执行语句1，并返回执行结果
                        如果该值为false，则执行语句2，并返回执行结果

              true?alert("语句1"):alert("语句2")  执行结果为语句1
              false?alert("语句1"):alert("语句2")  执行结果为语句2

              var a = 10
              var b = 20
              a > b ?alert("a大"):alert("b大")  执行结果为b大
              var a = 30
              var b = 20
              a > b ?alert("a大"):alert("b大")  执行结果为a大

                        如果条件表达式的求值结果是一个非布尔值
                            会将其转换为布尔值，然后再进行运算

              "hello"?alert("语句1"):alert("语句2")  执行结果为语句1
              ""?alert("语句1"):alert("语句2")       执行结果为语句2

              获取a 和 b中的最大值
              var a = 10
              var b = 20
              var c = 40
              var max = a > b ? a : b;  (我要判断a是否大于b 如果a大于b我执行a，把变量a赋值给max.如果a小于b我执行b，把b赋值给max.最后max就是谁大就是谁)
              console.log("max = "+max)

              获取a b c中的最大值
              (接上一步接着比较最终得出结果)var max = max > c ? max : c  (我再拿max和c比，如果max大返回max，如果c大，那么c赋值给max)

              (一步到位获取a b c中的最大值)  //这种写法不推荐使用，不方便阅读
              var a = 10
              var b = 20
              var c = 40
              var max = a > b ? (a > c ? a : c) : (b > c ? b : c)     (如果a大于b则a大，a大执行第一个表达式 比较a和c谁大，如果a比c大那么a就是最大的了，如果a比c小那么c就是最大的了)
                                                                      (如果a大于b不成立，那就执行第二个表达式 比较b和c谁大，如果b比c大那么b就是最大的了，如果b比c小那么c就是最大的了)
              console.log("max = "+max)
      */
    </script>
    <script id="逗号运算符">
      /*  , 使用可以分割多个语句，一半可以在声明多个变量时使用
            var a;
            var b;
            var c;
          使用,运算符同时声明多个变量
            var a , b , c;
          可以声明多个变量并赋值
            var a = 1 , b = 2 , c = 3;
      */
    </script>
    <script id="运算符的优先级">
      /*  就和数学中一样，在JS中也有优先级，
          比如：先乘除 后加减

          var result = 1 + 2 * 3   结果为7

          如果||的优先级高，或者两个一样高(应从左往右算) 第一个为true就不看第二个了，1&&3，第一个true返回第二个 返回3
          如果&&的优先级高，那么先算2 && 3，第一个true返回第二个 返回3，1 || 3 第一个为true就不看第二个了 返回1
          var result = 1 || 2 && 3
          console.log("result = "+result) 控制台结果为result = 1 所以&&的优先级高

          在JS中有一个运算符优先级的表
            在表中越靠上优先级越高，优先级越高越优先计算
            如果优先级一样，则从左往右计算
          但是这个表我们并不需要记忆，如果遇到优先级不清楚
            可以使用()来改变优先级

          var result = (1 || 2) && 3        控制台结果为3
      */
    </script>
    <script id="代码块">
      /*
       整体了，一个{}中的语句我们也称为一个代码块
              {}后不用编写;
            JS中的代码块，只具有分组的作用，没有其它的用途
              代码块内部的内容，在外部是完全可见的
            {
              alert("hello")
              console.log("你好")*  我们的程序是由一条一条语句构成的
            语句是按照自上向下的顺序一条一条执行的
            alert("hello")
            console.log("你好")
            document.write("语句")

            在JS中可以使用{}为语句分组，同一个{}中的语句我们称为是一组语句，它们要么都执行，要么都不执行
              换句话说它们就是一个
              document.write("语句")
            }
      */
    </script>
    <script id="if语句">
      /*
       *  流程控制语句
            JS中的程序时从上到下一条一条执行的
              alert("hello")
              console.log("你好")
              但从上到下一点也不智能，很傻。(就像一个傻小子，他爸让他出门买酒，傻小子开门一看天上正下刀子呢，但一想他爸让他买酒，还是迈开脚出门了，刚走两步被天上掉下的刀子插死了)
            通过流程控制语句可以控制程序执行流程
              使程序可以根据一定的条件来选择执行
            语句的分类:
              1:条件判断语句(我要对一个条件进行判断，如果条件成立执行，如果条件不成立则不执行)
              2:条件分支语句(满足条件一的话我执行条件一路线，满足条件二我执行条件二路线)
              3:循环语句(反复执行某一条语句)

       *  条件判断语句：
            使用条件判断语句可以在执行某个语句之前进行判断，
              如果条件成立，才会执行语句，如果条件不成立则语句不执行
            if语句
            语法一：
              if(条件表达式){
                语句
              }

              if语句在执行时，会先对条件表达式进行求值判断，
                如果条件表达式的值为true，则执行if后的语句
                如果条件表达式的值为false，则不会执行if后的语句
                if(true) alert("你猜我出来吗")                   执行
                if(false) alert("你猜我出来吗")                  不执行

                var a = 10
                if (a > 10) alert("a比10大")                    不执行

                var a = 11
                if (a > 10)
                    alert("a比10大")                    执行
                    alert("谁也管不了我")                执行

              if语句只能控制紧随其后的那个语句
                var a = 10
                if (a > 10)
                    alert("a比10大")                    不执行
                    alert("谁也管不了我")                执行

              如果希望if语句可以控制多条语句，可以将这些语句统一放到代码块中
                如果if这个条件表达式成立，则代码块里的代码都会执行，如果条件不成立，都不执行
                  var a = 10
                  if (a > 10){
                      alert("a比10大")
                      alert("谁也管不了我")
                  }                                     都不执行

              if语句后的代码块不是必须的，但是我们在开发中还是尽量写上代码块，即使if后只有一条语句

              与&& 需要同时满足多个条件时才会执行
              或|| 只要有一个满足就行
              var a = 25
              if (a > 10 && a <= 25){
                  alert("a大于10，并且a小于等于25")
              }                                         执行

            if语句
            语法二：
              if(表达式){
                语句
              }else{
                语句
              }

              if...else...语句
                当该语句执行时，会先对if后的条件表达式求值判断
                  如果该值为true,则执行if后的语句
                  如果该值为false,则执行esle后的语句

                  var age = 50
                  if(age >= 60){
                    alert("你已经退休了")
                  } else{
                    alert("你还没有退休")
                  }                                      你还没有退休

            if语句
            语法三：
              if(表达式){
                语句
              }else if{
                语句
              }else if{
                语句
              }else{
                语句
              }

              if...else if...else语句
                当该语句执行时，会从上到下依次对条件表达式进行求值判断
                  如果值为true,则执行当前语句。
                  如果值为false,则继续向下判断
                  如果所有的条件都不满足，则执行最后else后的语句
                  该语句中，只会有一个代码块被执行，一旦代码块执行了，则直接结束语句
                  var age = 70
                  if(age > 100){
                    alert("活着挺没意思的")
                  } else if(age > 80){
                    alert("你也老大不小的了")
                  } else if(age > 60){
                    alert("你已经退休了")
                  } else if(age > 30){
                    alert("你已经中年了")
                  } else if(age > 18){
                    alert("你已经成年了")
                  } else{
                    alert("你还是个小孩子")
                  }                                      你已经退休了
      */
    </script>
    <script id="if练习">
      /*  从键盘输入小明的期末成绩
          当成绩为100时，奖励一辆BMW
          当成绩为(80~99)时，奖励一台iphone13pro
          当成绩为(60~80)时，奖励一本参考书
          其它时，什么奖励都没有

          prompt()可以弹出一个提示框，该提示框中会带有一个文本框，
            用户可以在文本框中输入一段内容，该函数需要一个字符串""作为参数
            该字符串会作为提示框的提升文字
          用户输入的内容将会作为函数的返回值返回，可以定义一个变量来接收该内容

       *  var score = Number(prompt("请输入小明的期末成绩(0~100):"));
          if (score > 100 || score < 0 || isNaN(score)) {
            alert("请输入范围内的分数");
          } else {
            if (score == 100) {
              alert("奖励一辆BMW");
            } else if (score >= 80) {
              alert("奖励一台iphone13pro");
            } else if (score >= 60) {
              alert("奖励一本参考书");
            } else{
              alert("什么奖励都没有");
            }
          }

       *  大家知道，男大当婚，女大当嫁，那么女方家长要嫁女儿，当然要提出一定的条件
          高：180cm以上；
          富：1000万以上；
          帅：500以上；
          如果这三个条件同时满足，则："我一定要嫁给他"
          如果这三个条件有为真的情况，则："嫁把，比上不足比下有余"
          如果这三个条件都不满足，则："不嫁"

          var height = prompt("请输入身高(cm):")
          var money = prompt("请输入财富(万):")
          var face = prompt("请输入颜值(px):")
          if (height > 180 && money > 1000 && face > 500){
            alert("我一定要嫁给他")
          } else if(height || 180 && money || 1000 && face || 500){
            alert("嫁把，比上不足比下有余")
          } else{
            alert("不嫁")
          }

       *  编写程序，由键盘输入三个整数分别存入变量num1、num2、num3,
          对它们进行排序，并且从小到大输出。
          //prompt()函数的返回值时string类型的，直接在prompt()函数前加一个+，可以将它的返回值统一转换为number类型
          var num1 = +prompt("请输入第一个数")
          var num2 = +prompt("请输入第一个数")
          var num3 = +prompt("请输入第一个数")
          //找到3个数中最小的数
          if(num1 < num2 && num1 < num 3){
            //num1最小，比较num2和num3
            if(num2 < num3){
              alert(num1 + "," num2 + ","+num3)
            }else{
              alert(num1 + "," num3 + ","+num2)
            }
          } else if(num2 < num1 && num2 < num3){
            //num2最小，比较num1和num3
            if(num1 < num3){
              alert(num2 + "," num1 + ","+num3)
            } else{
              alert(num2 + "," num3 + ","+num1)
            }
          } else(num3 < num1 && num3 < num2){
            //num3最小，比较num1和num2
            if(num1 > num2){
              alert(num3 +"," num1 + ","+num2)
            } else{
              alert(num3 + "," num2 + ","+num1)
            }
          }
      */
    </script>
    <script id="条件分支语句">
      /*
       *  条件分支语句也叫switch语句
            语法：
              switch(条件表达式){
                case表达式:
                  语句
                  break
                case表达式:
                  语句
                  break
                default:
                  语句
                  break
              }
            执行流程：
              switch...case...语句
              在执行时会依次将case后的表达式和switch后的条件表达式的值进行全等比较
                如果比较结果为true,则从当前case处开始执行代码(当前case后的所有的代码都会执行)，我们可以在case的语句后面跟着一个break关键字，这样可以确保只会执行当前case后的语句，而不会执行其它的代码
                如果比较结果为flase,则继续向下比较
                如果所以的比较结果都为false，则只执行default语句
              switch语句和if语句的功能实际上有重复的，使用switch可以实现if的功能，同样使用if也可以实现switch的功能，所以我们使用时，可以根据自己的习惯选择

          根据num的值，输出对应的中文
          var num = 3
          if(num == 1){
            console.log("一")
          }else if(num == 2){
            console.log("二")
          }else if(num == 3){
            console.log("三")
          }                       这样做对是对的，只是太麻烦，每一个都在和num做相等的比较

          var num = 1
          switch(num){
            case 1:
              console.log("一")
          }

          var num = 2
          switch(num){
            case 1:               在执行时会依次将case后的表达式和switch后的条件表达式的值进行全等比较
              console.log("一")
            case 2:               比较结果为true,则从当前case处开始执行代码(当前case后的所有的代码都会执行)
              console.log("二")
            case 3:
              console.log("三")
            case 4:
              console.log("四")   控制台输出二 三 四
          }

       *  使用break可以退出switch语句
          如下所例，num = 2和case 2是全等的，全等则执行case 2后面的所有代码
            我们可以在case 2的语句后面跟着一个break关键字，这样可以确保只会执行当前case后的语句，而不会执行后面的代码

          var num = 2
          switch(num){
            case 1:               在执行时会依次将case后的表达式和switch后的条件表达式的值进行全等比较
              console.log("一")
            case 2:               比较结果为true,则从当前case处开始执行代码(当前case后的所有的代码都会执行)
              console.log("二")
              break;
            case 3:
              console.log("三")
            case 4:
              console.log("四")   控制台输出二 三 四
            default:
              console.log("非法数字")
          }
      */
    </script>
    <script id="switch练习">
      /*

       *  对于成绩大于60分的，输出"合格"。低于60分的，输出"不合格"
          方法一：
          var score = 60
          switch(score){
            case 60:
            case 61:
            case 62:
              console.log("合格")
              break;
          }

          6x等于60几
          7x
          8x
          9x
          100
          这几种情况都是合格
          从60~100数很多，一个个写不现时，那想想能不能把情况合并一下呢？
          6x / 10 = 6x
          7x / 10 = 7x
          8x / 10 = 8x
          9x / 10 = 9x      无论是91还是99/10 都得9，只不过不同的是91除9余1，99除9余9
          100 / 10 = 10

          var score = Number(prompt("请输入你的分数"));
          switch (parseInt(score / 10)) {
            case 10:
            case 9:
            case 8:
            case 7:
            case 6:
              console.log("合格");
              break;
            default:
              console.log("不合格");
              break;
          }

          方法二：
            var score = Number(prompt("请输入你的分数"));
            switch (true) {
              case score >= 60:           拿case后面的score >= 60:和true做比较，如果我case后面的值是true则执行下面的合格。>= 60如果成立那么返回true 和它全等 执行下面的合格。
                console.log("合格");
                break;
              default:
                console.log("不合格");
                break;
            }
      */
    </script>
    <script id="循环语句">
      /*
       *  向页面中输出连续的数字
          document.write(1);
          document.write(2);  但是这样写完这两个连一块了12，我希望我写完 1在一行，2在一行

          document.write(1+"<br />");
          document.write(2+"<br />");
          document.write(3+"<br />");
          document.write(4+"<br />");  在网页中输出，我们可以使用br标签，进行换行

          但是写1234有点麻烦，我还得一个个写，看这个数一直在自增，那不如这么写
          var n = 1
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")
          document,write(n++ +"<br />")

          但发现这块有个问题，输出半天，向页面输出这6个数字，每一行输出一个，每一行执行的都是一摸一样的 这样做太麻烦了，不方便
          那我现在希望 反复的执行这一条语句多少多少次，这时候我们就可以用到循环语句

       *  循环语句：
            通过循环语句可以反复的执行一段代码多次
       *  while循环
            语法：
              while(条件表达式){
                语句
              }
            while语句在执行时，
              先对条件表达式进行求值判断，
                如果值为true，则执行循环体
                  循环体执行完毕之后，继续对表达式进行判断
                  如果为true，则继续执行循环体，以此类推
                如果值为false，则终止循环

            //像这种将条件表达式写死 为true的循环，叫做死循环
            //该循环不会停止，除非浏览器关闭，死循环在开发中慎用
                var n = 1
                while(true){
                  alert(n++)
                }                对话框 1 2 3 4 5 6以此类推一直在执行，不停的在往外冒

            //我想循环停止怎么办呢？可以使用break来终止循环
                var n = 1
                while(true){
                  alert(n++)
                  break;
                }                这么写的话，执行1后直接退出，那我写循环就没有了


            //我们可以在break来个判断，只有n等于10的时候才终止
                var n = 1
                while(true){
                  alert(n++)
                  if(n == 10){
                    break;
                  }
                }
            while循环更常见的一个写法，我们来看看
            //创建一个循环，往往需要三个步骤
              //1.初始化一个变量
                var i = 0
              //2.在循环中设置一个条件表达式 //以下为例，判断i是否小于10，只有i小于10循环才会执行
                while(i < 10){
                  alert(i)
                  //3.定义一个更新表达式，每次更新初始化变量. //i++ 循环每执行一次 i自增一个.执行第一次i变成1，执行第二次i变成2，直到执行到10循环停止，所以这样我们的循环变成了一个执行10次的一个循环
                  i++;
                }                对话框 1 2 3 4 5 6 7 8 9没了，到10不执行

       *  do while循环
            语法：
              do{
                语句
              }while(条件表达式)
            执行流程：
              do while语句在执行时，会先执行循环体，
              循环体执行完毕以后，会对while后的条件表达式进行判断，
                如果结果为true，则继续执行循环体，执行完毕以后继续判断 以此类推
                如果结果为false，则终止循环

              while和do while实际上这两个语句功能类似，不同的是while是先判断后执行，而do while是先执行，后判断
              do while可以保证循环体至少执行一次，而while不能
      */
    </script>
    <script id="while练习">
      /*
       *  假如投资的年利率为5%，试求从一千块增长到五千块，需要花费多少年
          1000 1000*1.05
          1050 1050*1.05

          定义一个变量，表示钱的钱数
          var money = 1000;
          //第一年投资的钱数
          money = money * 1.05
          //第二年投资的钱数
          money = money * 1.05
          //第三年投资的钱数
          money = money * 1.05
          console.log(money)

          定义一个while循环来计算每年的钱数
          while(money < 5000){               //判断钱是否小于5000，到了5000循环停止
            money = money * 1.05             //循环每执行一次过了一年，每执行一次增长一次
          }
          console.log(money)

          年数怎么求？
          我们需要在循环体外定义一个计数器变量，统计保存我们代码的执行次数
          var money = Number(prompt("请输入你投资的本金"));
          var money = 1000;
          var count = 0
          while(money < 5000){               //判断钱是否小于5000，到了5000循环停止
            money = money * 1.05             //循环每执行一次过了一年，每执行一次增长一次
            count++;                         //循环每执行一次我们让count自增一个
          }
          console.log("一共需要"+count+"年")  一共需要三十三年


       *  从键盘输入小明的期末成绩
          当成绩为100时，奖励一辆BMW
          当成绩为(80~99)时，奖励一台iphone13pro
          当成绩为(60~80)时，奖励一本参考书
          其它时，什么奖励都没有

          //用户输入错误 我希望用户可以再输入一遍，那我们可以将prompt放入到循环中
          while (true) {
            var score = prompt("请输入小明的期末成绩(0~100):");
            //判断用户输入的值是否合法，用户输入合法则退出循环
            if (score >= 0 && score <= 100) {
              break;
            }
            alert("请输入有效的分数");
          }
          if (score > 100 || score < 0 || isNaN(score)) {
            alert("请输入范围内的分数");
          } else {
            if (score == 100) {
              alert("奖励一辆BMW");
            } else if (score >= 80) {
              alert("奖励一台iphone13pro");
            } else if (score >= 60) {
              alert("奖励一本参考书");
            } else {
              alert("什么奖励都没有");
            }
          }
      */
    </script>
    <script id="for循环">
      /*
       *  for语句，也是一个循环语句，也称为for循环
            在for循环中，为我们提供了专门的位置来摆放三个表达式：
              1.初始化表达式
              2.条件表达式
              3.更新表达式
            for循环的语法：
              for(①初始化表达式;②条件表达式;④更新表达式){
                ③语句
              }
              for(var i = 0 ; i < 10 ; i++){
                alert(i)
              }
            for循环的执行流程：
              ①执行初始化表达式，初始化变量(初始化表达式只会执行一次，就是在第一次的时候执行的)
              ②执行初始化表达式，判断是否执行循环
                如果为true,则执行循环体③
                如果为false,则终止循环
              ④执行更新表达式，更新表达式执行完毕 继续重复②
            for循环中的三个部分可以省略，也可以写在外部
              var i = 0
              for(;i < 10;){
                alert(i++)
              }
            如果在for循环中不写任何的表达式，只有两个;
              此时循环是一个死循环 会一直执行下去，所以慎用
              for(;;){
                alert("hello")
              }
      */
    </script>
    <script id="for循环练习">
      /*
       *  打印1-100之间所有奇数之和
          ①//打印1-100之间的数
            for(var i = 1 ; i <= 100 ; i++){
              alert(i)
            }
          ②//判断i是否为奇数。不能被2整除的数就是奇数。如果i除以2有余数则证明i是奇数
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 2 != 0){
                console.log(i)
              }
            }
          ③//那我现在的i有多少个？好多呀，那我需要把这些i一个一个加起来。加的话是不是得有一个地方保存这个结果呀
           //所以我们在循环的外面，创建一个变量，用来保存奇数之和
            var sum = 0
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 2 != 0){
                sum = sum + i
              }
            }
            console.log("奇数之和为："+sum)


       *  打印1-100之间所有7的倍数的个数及总和
          ①//打印1-100之间的数
            for(var i = 1 ; i <= 100 ; i++){
              alert(i)
            }
          ②//判断i是否是7的倍数。i能被7整除，就意味着i是7的倍数
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 7 == 0){
                console.log(i)
              }
            }
          ③//在循环的外面，创建一个变量，用来保存7的倍数之和
            var sum = 0
            var count = 0
            for(var i = 1 ; i <= 100 ; i++){
              if(i % 7 == 0){
                sum = sum + i
                count++
              }
            }
            console.log("7的倍数之和为："+sum)      //输出语句写在循环外面，因为我们只需要输出一次
            console.log("7的倍数的个数为："+count)  //使计数器自增1

       *  水仙花数
          水仙花数是值一个三位数，它的每 个位上的数字3次幂之和等于它的本身。
          (例如：13 + 53 + 33 = 153)，请打印所有的水仙花数
          ①//打印所有的三位数
          for(var i = 100 ; i < 1000 ; i++){
            console.log(i)parseInt()
          }
          ②//获取i的百位 十位 个位的数字
            //获取百位的数字
            var bai = parseInt(i / 100)                  //我们要的是整数位，小数位不要，所以我需要对它取整parseInt()
            //获取十位的数字
            var shi = parseInt((i - bai * 100)/10)       //355-百位等于55 55/10等于5.5 取整为5
            //获取各位的数字
            var ge  = i % 10
          ③//判断i是否是水仙花数
          if(bai * bai * bai + shi * shi * shi + ge * ge * ge == i){
            console.log(i)
          }

       *  在页面中接收一个用户输入的数字，并判断该数是否是质数
            质数：只能被1和它自身整除的数，1不是质数也不是合数，质数必须是大于1的自然数
          var num = prompt("请输入一个大于1的整数")                    //判断该值是否合法
          var flag = true                                            //创建一个变量来保存当前数的状态.为什么等于true呢?我们默认当前num是质数
          if(num <= 1){
            alert("该值不合法")
          }else{                                                     //判断num是否是质数  //获取2~num之间的数(把用户输入的num这些有可能整除的数取出来)
            for(i = 2 ; i < num ; i++){                              //i=2 i小于num(i从2开始 如果num是10，i就是2到9这些数)
              if(num % i == 0){                                      //判断num是否能被i整除.如果num能被i整除，则说明num一定不是质数
                flag = false
              }
            }
            //如果num是质数则输出                                                         //输出不能在循环体里面输出，因为结果是再for循环执行完了才出来的，得再for循环外输出。
            if(flag){                                                                   //所以我需要在这输出，但是问题又来了，我在这儿能不能知道for循环结果 不能。我需要结果从for循环里传出来，需要for循环的结果告诉下面num是不是质数，所以我在外面创建了一个变量，我默认当前num是质数，到了for循环体判断能否被i整除 能被整除一定不是质数，故flag变成false.变成false后，一到下面 我就知道它不是质数了
              alert(num + "是质数！")
            }else{
              alert(num + "不是质数！")
            }
          }
      */
    </script>
    <script id="嵌套的for循环">
      /*  需求
            通过程序，在页面中输出如下图形
            *****
            *****
            *****
            *****
            *****
          //通过一个for循环来输出图形
          //这个for循环执行几次，图形的高度就是多少
          //它可以控制图形的高度
          for (i = 0; i < 5; i++) {
            document.write("*****<br />");     我想高度是20，我可以把i<5改成i<20
          }
          //可是高度灵活 宽度不灵活

       *  在循环的内部再创建一个循环，用来控制图形的宽度
          目前我们外部的for循环执行1次，内部的就会执行5次
          内层循环可以决定图形的宽度 执行几次，图形的宽度就是多少
          for (i = 0; i < 5; i++) {
            for (j = 0; j < 5; j++) {    里面的for循环我想宽度是20，我可以把i<5改成i<20
              document.write("*");
            }
            document.write("<br />");    执行换行
          }
          现在输出的图形，我感觉不太好看 它们行与行之间距离有点远，*与*之间的距离几句为0，我希望它们之间距离远一点
            那我们在document.write("* ");加了个空格，有用。再加空格就没用了，因为最终是写到网页里的，写多少空格都当成一个 所以想要它起作用就不能这么写了
            document.write("*&nbsp;&nbsp;");

       *  需求
            通过程序，在页面中输出如下图形
            *               1(第一行)     j<1(宽度一个*           i=0(i+1正好等于行号)
            **              2            j<2                    i=1
            ***             3            j<3                    i=2
            ****            4            j<4                    i=3
            *****           5            j<5                    i=4

          for (var i = 0; i < 5; i++) {
            for (var j = 0; j < i + 1; j++) {         //。这样 第一次执行的时候i是0，j < i + 1，j小于1那么第一行输出一个*。第二行的时候i是1，1+1=2 j < 2，小于2那么第二行输出两个*
              document.write("*&nbsp;&nbsp;&nbsp;");
            }
            document.write("<br />");    //执行换行
          }

       *  需求
            通过程序，在页面中输出如下图形
            *****           1(第一行)     j<5(5-0)     i=0(i+1正好等于行号)
            ****            2            j<4(5-1)       i=1
            ***             2            j<3(5-2)       i=2
            **              2            j<2(5-3)       i=3
            *               2            j<1(5-4)       i=4

          for (var i = 0; i < 5; i++) {
            for (var j = 0; j < 5 - i; j++) {
              document.write("*");
            }
            document.write("<br />");
          }
      */
    </script>

    <script id="练习">
       /*
        *  练习1：打印99乘法表
               1*1=1
               1*2=2 2*2=4
               1*3=3 2*3=6 3*3=9
               1*4=4 2*4=8 3*4=12 4*4=16
               ......9*9=81


            //创建外层循环，用来控制乘法表的高度
            for (i = 1; i < 10; i++) {
              //创建内层循环，用来控制内层图形的宽度
              for (j = 1; j <= i; j++) {
                document.write(j + "*" + i + "=" + i * j + "&nbsp;" + "&nbsp" + "&nbsp" + "&nbsp");
              }
              //在循环外输出一个换行(注意是在内层循环执行完以后执行换行)
              document.write("<br />");
            }


            //但是现在写完有的地方没有对齐，有点不好看 我希望能好看些
            for (i = 1; i < 10; i++) {
              for (j = 1; j <= i; j++) {
                document.write("<span>" + j + "*" + i + "=" + i * j + "</span>"); //现在公式都在span标签里套着，有span了我们就可以给它设置样式了
              }
              document.write("<br />");
            }
            <style type="text/css">
              span{
                width: 100px;                     //span是个内联元素，我们要让它生效需给它换成行内块元素
                display: inline-block;            //现在就对齐了，挺好看
              }
            这样做好处比较灵活，假如我想换10*10乘法表 只需修改i i<11即可
            </style>



        *  练习2：打印出1~100间所有的质数
           //1我们知道它不是质数，打印2-100之间所有的数
            for (var i = 2; i <= 100; i++) {
              //判断i是否是质数
              //先要获取到2到i之间所有的数。假设i是3，我就要获取到2，看看3能不能被2整除，如果不能整除，证明3就是质数。
              for(var j =2;j<i;j++){  //j是多少？假设i是3,j就是2.假设i是4,j就是2、3.
                //判断i是否能被j整除
                if(i % j == 0) {//如果证明i是质数这个比较麻烦，所以我们反着证明i不是质数，一旦进入我们这个判断，就一定能证明我们i不是质数，我们把所有的不是质数的数取出来剩下的都是质数
                  //如果进入判断则证明i不是质数
                }
              }
              //如果是质数，则打印i的值(在这我知道i是质数吗？不知道。我们需要创建一个变量保存结果)
              console.log(i)
            }



            //创建一个布尔值，用来保存结果，默认i是质数
            for (var i = 2; i <= 100; i++) {
              var flag = true
              for(var j =2;j<i;j++){
                if(i % j == 0) {
                  //如果进入判断则证明i不是质数，修改flag值位false
                  flag = false
                }
              }
              //如果是质数，则打印i的值(在这我知道i是质数吗？不知道。我们需要创建一个变量保存结果)
              if(flag){
                console.log(i)
              }
            }
       */
    </script>

    <script id="break和continue">
      /*
       *  break关键字可以用来退出switch或循环语句
            不能在if语句中使用break和continue

          例:
              for (var i = 0; i < 5; i++) {
                console.log(i);
              }                                        //控制台0 1 2 3 4
              for (var i = 0; i < 5; i++) {
                console.log(i);
                break;
              }                                        //控制台0，因为添加执行break关键字 循环立即结束
              //我不希望它只执行一次 我希望它执行几次
                for (var i = 0; i < 5; i++) {
                  console.log(i);
                  if (i == 2) {
                    break;                   //这个break是对for循环起作用的，并不是对if语句起作用的。
                  }
                }                                      //控制台0 1 2

                for (var i = 0; i < 5; i++) {
                  if (i == 2) {
                    break;                   //这个break是对for循环起作用的，并不是对if语句起作用的。
                  }
                  console.log(i);
                }                                      //控制台0 1

                for (var i = 0; i < 5; i++) {
                  console.log("外层循环:" + i);
                  for (var j = 0; j < 5; j++) {
                    console.log("内层循环:" + j);
                  }
                }                                      //控制台一个外层循环后边跟着五个内层循环

                //那现在来看，我在内层循环里写个break，也就是说内层循环一执行就停止，那会不会对外层循环产生影响？
                for (var i = 0; i < 5; i++) {
                  console.log("外层循环:" + i);
                  for (var j = 0; j < 5; j++) {
                    break;
                    console.log("内层循环:" + j);
                  }
                }                                      //控制台外层循环0 1 2 3 4。对外层循环没有影响。所以注意，break只对离它最近的产生影响。在这里只结束内层循环，而没有结束外层循环。

                //那现在我有这样一个需求，我觉得这样做不方便，希望break也可以终止外层循环
              我们可以为循环语句创建一个名字,来标识当前的循环
              lable:循环语句 //表示我这个循环的名字叫lable
              使用break语句时，可以在break后面跟着一个lable，这样break将会结束指定的循环，而不是最近的。
                lable:
                for (var i = 0; i < 5; i++) {
                    console.log("外层循环:" + i);
                    for (var j = 0; j < 5; j++) {
                      break lable;
                      console.log("内层循环:" + j);
                    }
                  }                                    //控制台 外层循环0
       *  continue关键字可以用来跳过当次循环
            同样continue也是默认只会对离它最近的循环起作用
          例:
              for (var i = 0; i < 5; i++) {
                  if (i == 2) {                        //i等于2，2跟2相等，执行continue。continue一旦执行，这次循环直接跳过。换句话说，continue下的内容不执行 直接执行i++，i自增完执行条件表达式，再执行下次循环。说白了 continue的作用就是跳过当次循环
                    continue;
                  }
                  console.log(i);
                }                                      //控制台0 1 3 4

                for (var i = 0; i < 5; i++) {
                  for (var j = 0; j < 5; j++) {
                    console.log("--->" + j);
                  }
                  console.log("@--->" + i);
                }                                      //控制台五个内层循环后面跟着一个外层循环

                for (var i = 0; i < 5; i++) {
                  for (var j = 0; j < 5; j++) {
                    if (j == 1) {
                      continue;
                    }
                    console.log("--->" + j);
                  }
                  console.log("@--->" + i);
                }                                      //控制台0 2 3 4四个内层循环后面跟着一个外层循环。内层循环没有1了。对外层循环没有影响。所以注意，continue只对离它最近的产生影响。

                for (var i = 0; i < 5; i++) {
                  for (var j = 0; j < 5; j++) {
                    continue;
                    console.log("--->" + j);
                  }
                  console.log("@--->" + i);
                }                                      //控制台外层循环0 1 2 3 4。内层循环不执行了，因为每一次都跳过了。但是不会对外层循环产生影响

                想对外层循环产生影响怎么办呢？
                lable:循环语句 //表示我这个循环的名字叫lable
              使用continue语句时，可以在continue后面跟着一个lable，这样continue将会跳过指定的循环，而不是最近的。
                lable:
                for (var i = 0; i < 5; i++) {
                  for (var j = 0; j < 5; j++) {
                    continue lable;
                    console.log("--->" + j);
                  }
                  console.log("@--->" + i);
                }                                 //控制台什么也没有


       *  质数练习补充
          在以后的开发中，很多的精力需要放在程序性能的提升。什么是性能？代码的执行时间。同样的程序同样的功能 一个程序执行需要花费10秒钟，另一个需要花费1分钟，那我们说哪个性能好？ 10秒钟的那个。也就是说我程序执行越快，性能越好
          for (var i = 2; i <= 100; i++) {
            var flag = true;
            for (var j = 2; j < i; j++) {
              if (i % j == 0) {
                //判断是不是质数，如果进入判断那么证明这个数不是质数
                flag = false;
                //一旦进入判断，则证明i不可能是质数了，此时循环再执行已经没有任何意义，可以使用break来结束循环
                break;
              }
            }
            if (flag) {
              console.log(i);
            }
          }

       *  测试如下的程序性能
          在程序执行前，开启计时器
          console.time("计时器的名字")可以用来开启一个计时器 //一个页面里可能有多个计时器，所以我们通过名字来区分一下
          它需要一个字符串作为参数，这个字符串会作为计时器的标识
          console.time("test")
          for (var i = 2; i <= 100; i++) {
            var flag = true;
            for (var j = 2; j < i; j++) {
              if (i % j == 0) {
                //判断是不是质数，如果进入判断那么证明这个数不是质数
                flag = false;
                //一旦进入判断，则证明i不可能是质数了，此时循环再执行已经没有任何意义，可以使用break来结束循环
                break;
              }
            }
            if (flag) {
              console.log(i);
            }
          }
          //终止计时器
          //console.timeEnd()用来停止一个计时器，需要一个计时器名字作为参数
          console.timeEnd("test")
          //加break,test: 0.801025390625 ms

          console.time("test")
          for (var i = 2; i <= 100; i++) {
            var flag = true;
            for (var j = 2; j < i; j++) {
              if (i % j == 0) {
                flag = false;
              }
            }
            if (flag) {
              console.log(i);
            }
          }
          console.timeEnd("test")
          //不加break,test: 2.7080078125 ms
      */
    </script>
    <script id="质数练习补充">
      /*
       *  质数100以内最大的是97，那我们来想一想，对于97这种情况，也就是说我i的值是97，那i的值是97的时候我的j应该是几？
          2~96
          我要分别检查2~96之间这些数是不是能整除97。那我们想 这些数是不是有点多啊？
          多
          那96还用不用看了？
          不用看了 96压根就不可能了呀，我除了1最小 是不就剩2了，2*96将近200了，所以是不可能的
          那咱再说一个稍微小一点的数，比如说19
          我要分别检查2-18这件这些数
          那我们假设 如果19检查完2了，19/2=9.5    9.5以后的值有没有可能是19的因数？10有没有可能？
          一点可能也没有，为什么呀？最小的是1，然后是2，10跟什么乘也不可能得19
          所以9.5以后的值我没有必要再去检查了
          那我们想想，这值我们能不能进一步给它优化呀？
          我们会发现我们的因数 比如说36  1*36得36
                                      2*18得36  2和18是36的因数
                                      3*12得36  3和12是36的因数
                                      4*9得36  4和9也是36的因数
                                      6*6得36  6是36的因数 (注意在这一刻这两个因数是相等的)
          因数都是一对儿一对儿的
          6*6得36  6是36的因数 (注意在这一刻这两个因数是相等的)，到这儿了往下还有没有新的因数了？
          没了 6往下对于36来说都是重复的因数了
          对于36来说，找因数，找到6就行了
          同样对于97来说，用不用非得找到96啊？
          不用。那找到谁合适？
          36 这个6对于36来说是根号下36，同样我要是想找97的话我要找到根号下97就行了
          因为根号下97以后，即使有因数，那是不就跟前面重复了。如果到根号97了还没有因数，那证明没有新的因数了
          也就是说到根号97以后，我就没必要再看了

          那么我们注意j < i这块儿 实际上这个值定的有点大了，应该是根号下i。
          那问题来了 写个根号打不出来 它不认识。
          那我需要对i进行开方
          那怎么对一个数进行开方呢？
          //可以通过Math.sqrt()对一个数进行开方
          var result = Math.sqrt(4)
          console.log //控制台结果为2。
          var result = Math.sqrt(97)
          console.log //控制台结果为9.848857801796104。
          那就意味着9.8以后没有97新的因数了，没有了，在之前都已经检查过了，所以9.8就相当于97所有因数的中线。对于97来说只用检查到9.8了，10往后都不用看了。刚才还要检查到96呢，这一下检查效率提升很多。
          所以这块注意了，我们要检查的话就不用j < i了，应该是j <= Math.sqrt(i)

          for (var i = 2; i <= 100; i++) {
            var flag = true;
            for (var j = 2; j <= Math.sqrt(i); j++) {
              if (i % j == 0) {
                flag = false;
                break;
              }
            }
            if (flag) {
              console.log(i);
            }
          }
      */

    </script>

    <script id="对象的简介">
      /*
       *  js中数据类型
            String 字符串
            Number 数值
            Boolean 布尔值
            Null 空值
            Undfined 未定义
              以上五种数据类型属于基本数据类型，以后我们看到的值只要不是上边的五种，剩下的全都是对象
            Object 对象
            //上面五种类型基本上可以把我的任何值都可以表示了，那为什么还需要对象呢？既然要引入一个新的数据类型，说明上面五个还有不足的，有不足我才要引入一个新的内容

            基本数据类型都是单一的值"hello" 123 true
              值和值之间没有任何的联系

            假设这js中表示一个人的信息，(name gender age),
              var name = 张三
              var gender = 男
              var age = 18
              //我们创建了三个变量 三个变量共同表示一个人的信息，用基本数据类型可以表示，但我们发现一个问题，它们三个没有关系，这三个是完全独立的
              //光从变量上来看name是一个变量，gender是一个变量，age是一个变量，它们并不是一个整体
            如果我们使用基本数据类型的数据，我们所创建的变量都是独立，不能成为一个整体
            对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性
              //对象就像一个容器 可以装不同的属性，用着方便。
              //变量都放在一块容易乱，可以把它们保存到不同的对象里，通过对象去调用

        *   对象的分类
              1.内建对象
                由ES标准中定义的对象，在任何的ES实现中都可以使用
                比如Math String Number Boolean Function...
              2.宿主对象
                由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
                比如BOM(浏览器对象模型) DOM(文档对象模型)，注意这个不是指两个对象 是指两组对象 BOM里有一堆对象 DOM里有一堆对象
                  //比如说我们常用的console.log()这里的console就是一个对象
                                   document.write这里的document也是一个对象
                  //这两个对象我们没有创建，直接拿来用的，所以注意 这两个对象是由浏览器提供的 叫做属主对象
              3.自定义对象
                由开发人员自己创建的对象
      */

    </script>

    <script id="对象的基本操作">
      /*
       *  创建对象
          使用new关键字调用的函数，是构造函数constructor
            构造函数是专门用来创建对象的函数
          使用typeof检查一个对象时，会返回object
            var obj = new Object()  //new Object()就表示我们创建好了一个对象并赋值给变量obj
            console.log(obj)
              //控制台输出[object Object] 那么这就是一个对象。那现在我们相等于有这么一个塑料袋了，但注意了这塑料袋它没有东西 它是一个空的
              //在外部浏览器如果直接输出一个对象的话
                //Object{} 表示我这个对象是通过Object函数创建的 但是{}里啥也没有，表示我这对象是一个空的对象
            console.log(typeof obj)
              //控制台输出object

       *  在对象中保存的值称为属性
          向对象添加属性
            语法:
              对象.属性名 = 属性值

            //向obj中添加一个name属性
            obj.name = "张三"
            //向obj中添加一个gender属性
            obj.gender = "男"
            //向obj中添加一个age属性
            obj.age = "18"
            //控制台输入console.log(obj)
            //控制台输出{name: '张三', gender: '男', age: 18}
            //现在name gender age 它们有关系了 都属于同一个对象的属性

          光往塑料袋里装没用，还得能取出来
       *  读取对象中的属性
            语法:
              对象.属性名

            console.log(obj.name)
            //控制台输出张三
          如果读取对象中没有的属性，不会报错 而是返回undefined
            console.log(obj.hello)
            //控制台输出undefined

          我能读取了 那我能不能去修改这个属性啊？假如说我这个人不想叫张三了，我想换一个名，那怎么办呢？
       *  修改对象的属性值
            语法:
              对象.属性名 = 新值//和向对象添加属性是一样的，只不过我这种是把之前的值给覆盖掉了

       *  删除对象的属性
            语法:
              delete 对象.属性名

            delete obj.name
            console.log(obj.name)
            //控制台输出undefined
      */
    </script>

    <script id="属性名和属性值">
      /*
       *  var obj = new Object
          obj.name = "孙悟空" //向obj这个对象里添加了一个属性 属性名是name 属性值是孙悟空

       *  属性名
            对象的属性名不强制要求遵守标识符的规范
              什么乱七八糟的名字都可以使用
            但是使用时还是尽量按照标识符的规范去做
            如果使用特殊的属性名，不能采用.的方式来操作
              需要使用另一种方式
              语法:
                对象["属性名"] = 属性值
              读取时也需要采取这种方式

              var obj = new Object();
              obj.name = "张三";
              obj["123"] = 789;
              console.log(obj["123"]);    //控制台输出789

            使用[]这种形式操作属性，更加的灵活
              在[]中可以直接传递一个变量，这样变量值是多少就会读取哪个属性
              var obj = new Object();
              obj.name = "张三";
              obj["123"] = 789;
              var n = "123"            //变量n的值是123
              console.log(obj[n]);    //控制台输出789

       *  属性值
            JS对象的属性值，可以是任意的数据类型
              obj.test = undefined;
              obj.test = null
              obj.test = true


              甚至也可以是一个对象

                var obj = new Object();
                obj.name = "张三";
                obj.test = undefined;

                var obj2 = new Object();
                obj2.name = "猪八戒";

                //将obj2设置为obj的属性
                obj.test = obj2;  //让obj的test属性的值是一个对象

                //控制台输入console.log(obj)
                //浏览器输出{name: '张三', test: {…}}
                              name: "张三"
                              test: {name: '猪八戒'}

              那我现在想读取obg2的属性怎么取？
                console.log(obj.test.name)

       *  in 运算符
            通过该运算符可以检查一个对象中是否含有指定的属性
              如果有则返回true
              没有则返回false
            语法:
              "属性名" in 对象

            //检查obj中是否含有test2属性
              var obj = new Object();
              obj.name = "张三";
              obj.test = undefined;
              var obj2 = new Object();
              obj2.name = "猪八戒";
              obj.test = obj2;
              console.log(obj.test.name);
              //控制台输入console.log("test2" in obj)
              //控制台输出false
      */
    </script>

    <script id="基本数据类型和引用数据类型">
      /*
       *  基本数据类型:
            String 字符串
            Number 数值
            Boolean 布尔值
            Null 空值
            Undfined 未定义
          引用数据类型:
            Object

          //为什么这么分 他们之间有什么区别？我们来看一下
            var a = 123
            var b = a
            a++
            console.log("a = "+a)  //控制台输出a = 124，a自增后等于124
            console.log("b = "+b)  //控制台输出b = 123, b等于a自增前的123
            //也就是说a和b是它们俩个的值是完全独立的，一个值的变化会不影响其他值

          //我们再看一个
            var obj = new Object()
            obj.name = "孙悟空"
            console.log(obj.name) //控制台输出 孙悟空

            var obj = new Object();
            obj.name = "孙悟空";
            var obj2 = obj;
            console.log(obj.name);
            console.log(obj2.name);
            //控制台输出:
                        孙悟空
                        孙悟空

          //修改obj的name属性
            var obj = new Object();
            obj.name = "孙悟空";
            var obj2 = obj;
            obj.name = "猪八戒";
            console.log(obj.name);
            console.log(obj2.name);
            //控制台输出:
                        猪八戒
                        猪八戒

       *  基本数据类型和引用数据类型的区别
            基本数据类型保存的是值
            引用数据类型保存的是内存地址

          变量和对象在内存里的结构
          内存分为两大块
            栈内存
            堆内存
          JS中的变量都是保存到栈内存中的
            基本数据类型的值直接在栈内存中存储
            值与值之间是独立存在的，修改一个变量不会影响其它的变量
            var a = 123
            var b = a
            a++


            栈内存
            变量    值
            a       123--->在a++后变成了124。此时不会对变量b产生任何影响
            b       123//将变量a的值复制到b，a和b的值都是123，但是a的123和b的123没有关系，它们是互相独立的

       *  对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间
          而变量保存的是对象的内存地址(那这个内存地址就是我们所说的对象的引用)，如果两个变量保存的是同一个变量的引用，当一个通过一个变量修改属性时，另一个也受会到影响。因为它们不是独立的
            var obj = new Object()
            obj.name = "孙悟空"  //现在是往obj里添加name属性叫孙悟空，添加不是往变量里添加，我是往变量里对应的内存地址的对象里添加的。所以注意，在变量里只是保存的对象的引用 一个地址
            var obj2 = obj       //没有创建新的对象，只是让obj2等于obj，就相当于把obj的地址往obj2复制一遍，它俩保存的是同一个内存地址。也就是说现在的obg2指向的也是这个对象。
            obj.name = "猪八戒"  //现在我修改了obj的name为猪八戒了，obj2对应的对象也变了，因为它们是同一个对象

            栈内存                                  堆内存
            变量    值                              一旦看见new就意味着我要在堆内存里开辟出一个新的空间，这个空间专门用来保存这个对象
            obj     0x123                           变量和对象没关系 没关系变量就操作不了这个空间
            obj2    0x123                           这个空间是在内存里开辟的，既然是内存里开辟的它就有一个内存地址，假设这块儿的内存地址是0x123 这个内存地址专门用来保存obj这个对象的
                                                    那它们俩怎么建立联系？
                                                    在变量里保存的是对象的内存地址
                                                    所以我这obj保存的实际上是0x123，那变量obj和对象有关系了
                                                    所以注意 对象本身是它是没有名字的，它只有一段内存地址
                                                    name = "猪八戒"

            //设置obj2为null
            var obj = new Object()
            obj.name = "孙悟空"
            var obj2 = obj
            obj.name = "猪八戒"
            obj2 = null
            //控制台输出Object
                        null
            //奇怪，刚才不是说两个变量改一个会影响到另一个吗？这回怎么又不影响了，这是 为什么啊？
            栈内存                                  堆内存
            变量    值                              相当于之前我这个变量和对象建立了连接，但是当它把它设置为null了以后，它们的链接断开了。但是obj不受影响
            obj     0x123                           所以注意，当修改变量值的时候，对我们其它对象不会产生影响
            obj2    null

       *  当我们比较两个基本数据类型的值时，就是比较值
            var c = 10
            var d = 10
            console.log(c == d)
            //控制台输出true

       *  而比较两个引用数据类型时，它是比较的对象的内存地址。如果两个对象是一模一样的，但是地址不同，它也会返回false
            var obj3 = new Object()
            var obj4 = new Object()
            obj3.name = "沙和尚"
            obj4.name = "沙和尚"
            console.log(obj3 == obj4)
            //控制台输出false
            栈内存                                  堆内存
            变量    值                              开辟新空间0x111 name = 沙和尚
            obj3    0x111                           开辟新空间0x222 name = 沙和尚
            obj4    0x222
            //虽然这两个对象name一样，但是内存地址不一样
      */
    </script>

    <script id="对象字面量">
      /*
       *  //创建一个对象
          var obj = new Object 使用new关键字调用构造函数来创建一个对象，但是这种方式实际上不是我们用的最多的，这种方式稍微有点麻烦，我们有一个更简单的方式

       *  使用字面量来创建一个对象
            就像写var a = 123 //123就是一个字面量
            var obj = {}      //这个大括号我们就叫对象字面量
            console.log(obj)  //控制台输出Object
          用{}这种方式和new Object这种方式它们本质上是一样的，但{}这种方式更加省事儿

          用构造函数创建的对象我们只能先创建对象，再往对象里添加属性
          使用对象字面量，可以在创建对象时，直接指定对象中的属性
       *  语法:
            {属性名:属性值,属性名:属性值...}
              对象字面量的属性名可以加引号也可以不加，建议不加，但是如果要使用一些特殊的名字，则必须加引号

            var obj = {name:"猪八戒"}  //这就表示我创建了一个对象，同时为这个对象里添加了一个属性，属性的名字叫name，属性的值叫猪八戒
            console.log(obj)
            //控制台输出Object
                          name: "猪八戒"
            var obj = {name:"猪八戒",age:28}  //这就表示我创建了一个对象，对象里有两个属性，一个时name，一个时age
            console.log(obj)
            //控制台输出:Object
                          age: 28
                          name: "猪八戒"
            但我们发现这种方式写完以后 结构不是很清楚，那怎么写呢？

       *  属性名和属性值是一组一组的名值对结构
            名和值之间使用:连接，多个名值对之间使用,隔开
            如果一个属性之后没有其它的属性了，就不要写,了
            var obj = {
              name:"猪八戒",
              age:28
            }
            这样写清晰，我一看我这对象里两个属性 name，age，保存后效果是一样的
            console.log(obj)
            //控制台输出Object
                          age: 28
                          name: "猪八戒"
      /*
    </script>

    <script id="对象的方法">
      /*
       *  //创建一个对象
            var obj = new Object()

          //向对象中添加属性
            obj.name = "孙悟空"
            obj.age = 18                     //我向obj这个对象添加了两个属性

          //对象的属性可以是任何的数据类型，也可以是个函数
            obj.sayName = function(){        //我将匿名函数赋值给了obj的sayname属性
            }
            console.log(obj.sayName)
            //控制台输出
                        ƒ () {

                        }


            obj.sayName = function () {
              console.log(obj.name);
            };
            console.log(obj.sayName);
            //控制台输出
                        ƒ () {
                          console.log(obj.name);
                        }                    //函数里有东西了

            //对象的属性也可以是一个函数，那我能不能调用函数？
            obj.sayName = function () {
              console.log(obj.name);
            };
            //函数对象()调用函数
            obj.sayName()
            //控制台输出孙悟空

          函数也可以成为对象的属性
            如果一个函数作为一个对象的属性保存，
            那么我们称这个函数是对象的方法
            调用这个函数就是调用对象的方法(method)

          //那现在来看 sayName这个属性对应着一个函数，那么我们称sayName是obj的方法

            function fun(){
                   console.log(obj.name);
               };
            fun()

          //调方法
            obj.sayName();
          //调函数
            fun();

            var obj2 = {x
              name: "猪八戒",
              age: 18,
              sayName: function () {
                console.log(obj2.name);
              },
            };
            obj2.sayName();
            //控制台输出猪八戒


       *  枚举对象中的属性
            var obj = {
              name:"孙悟空",
              age:18,
              gender:"男",
              address:"花果山"
            };
          //在开发中，对象里有什么属性我们不一定都知道，我们需要知道对象里有哪些属性
          //假设我不知道obj里有哪些属性，但现在我却需要使用这个对象，那怎么办呢？此时就用到了枚举对象中的属性
          //什么叫枚举？就是把对象中的这些个属性一个个取出来

          枚举对象中的属性
          使用for...in语句
            语法:
              for(var 变量 in 对象){

              }
            for...in语句 对象中有几个属性，循环体就会执行几次

              for(var n in obj){
                console.log("hello")
              }
              控制台输出:
                        hello
                        hello
                        hello
                        hello

            每次执行时，会将对象中的一个属性的名字赋值给变量

              for(var n in obj){
                console.log("属性名:" + n)
              }
              控制台输出:
                        属性名:name
                        属性名:age
                        属性名:gender
                        属性名:address

              for(var n in obj){
                 console.log("属性值:"+obj[n]);
              }
              控制台输出:
                        属性值:孙悟空
                        属性值:18
                        属性值:男
                        属性值:花果山



      */

    </script>

    <script id="函数">
      /*
       *  函数function
            函数也是一个对象
            函数中可以封装一些功能(代码)，在有需要的时候可以执行这些功能(代码)
            函数中可以保存一些代码在需要的时候使用
            使用typeof检查函数对象时，会返回function

       *  创建一个函数对象
            var fun = new Function()
            console.log(typeof fun)
          //可以将要封装的代码以字符串的形式传递给构造函数    //(换句话说 在构造函数里 我可以传一个字符串)
            var fun = new Function("console.log('hello 这是我的第一个函数');");    //我这个函数构造里传的是一个字符串，但是这字符串有特点了，这字符串是一段js代码，等于是我现在把这一段代码存到了我们函数对象里
            console.log(fun);
            //控制台输出:
                        ƒ anonymous(
                        ) {
                        console.log('hello 这是我的第一个函数');
                        }

          //封装到函数中的代码不会立即执行                  //(也就是说我仅仅把它给存起来了，就像枪一样 我把子弹给装上了，它得等我开枪)
          //函数中的代码会在函数调用的时候执行
          //调用函数 语法:
              函数对象()
              fun()
          //当调用函数时，函数中封装的代码会按照我编写的顺序执行
            var fun = new Function("console.log('hello 这是我的第一个函数');");
            fun()                                                               //控制台输出:hello 这是我的第一个函数
          //调用几次执行几次
            var fun = new Function("console.log('hello 这是我的第一个函数');")
            fun()                                                               //控制台输出:hello 这是我的第一个函数
            fun()                                                               //控制台输出:hello 这是我的第一个函数
            fun()                                                               //控制台输出:hello 这是我的第一个函数
            //这有什么好处？假如我想重复的去执行这行代码，我在24行想用我调用一下，我在240行想用我调一下，用起来比较方便。并且我想修改的话不用分别修改
          不过我们在实际开发中很少使用构造函数来创建一个函数对象

       *  使用函数声明来创建一个函数
            语法：
              function 函数名([形参1，形参2...形参n]){                            //[]意思表示可选的，里面的写不写都行,{}里函数体
                语句
              }

              function fun2 (){

              }
              console.log(fun2)                                       //控制台输出:ƒ fun2() {}//没有代码，因为我还没有往里填
          //那现在我要封装代码怎么封装啊?直接写在函数体里
              function fun2 (){
                console.log("这是我的第二个函数")
              }
              fun2()                                                  //控制台输出:这是我的第二个函数(我可以在函数体里封装大量的代码，调用的时候只需要调用变量名fun2()一行代码搞定)

       *  使用函数表达式来创建一个函数
            语法：
              var 函数名 = function ([形参1，形参2...形参n]){
                语句
              }
              //匿名函数
              function(){
                console.log("我是匿名函数中封装的代码")
              }                                                       //匿名函数无意义，因为没用名，写完也用不了它
              //所谓函数表达式就是创建一个匿名函数，然后将匿名函数的对象赋值给变量
              var fun3 = function ([形参1，形参2...形参n]){
                console.log("我是匿名函数中封装的代码")
              };
              fun3()
      */
    </script>
    <script id="函数的参数">
      /*  上面我们知道函数的方式及使用，但是函数的里面是封装的一些功能，封装的一些可执行的代码的，但我们发现 现在我们的功能没有实际上的意义，所以这里面我们要有有那么一点意义的函数
       *  函数的参数
          在函数的参数之前呢，我们先创建一个函数
          那既然我们说了，函数的里面是封装的一些功能的，那我就要定一个具有一定功能的函数
          比如说：定义一个求两个数和的函数
            function sum(){
              console.log(1+1)
            }                            //现在保存 没执行?调用
            sum()                        //保存 控制台结果位2.
          //现在的问题是我这是求两个和的函数，但只会算1+1 写死了
          function sum(){
              var a = 1
              var b = 1
              console.log(a+b)
            }
            sum()                        //保存 控制台结果位还是2.这比刚才还麻烦了，但是已经有进步了，我知道使用变量了
          //但是问题来了，我这变量的值是死的呀，那还不如不写呢，那我这两个值什么时候定啊，在调用的时候定。如果在调用的时候我希望是2+3，那就是a=2 b=3。
          //我希望在我调用的时候，我才决定我要算谁+谁。定义的时候不定，在调用的时候定
       *  可以在函数的()中来指定一个或多个形参(形式参数) //什么是形式参数 形式上的，它没有值 我先给你占个地儿
          多个形参之间使用,隔开。声明形参就相当于在函数的内部声明了对应的变量
          但是并不赋值
            function sum(a,b){
              console.log(a+b)
            }
       *  在调用函数时，可以在()中指定实参(实际参数)
            实参将会赋值给函数中对应的形参
            sum(1,2)    //控制台输出:3

       *  调用函数时 解析器不会检查实参的类型
            所以要注意，是否有可能会接收到非法的参数，
            如果有可能，则需要对参数进行类型的检查
          函数的实参可以是任意的数据类型
           function sum(a,b){
              console.log(a+b)
            }
           sum(123,"hello")            //控制台输出:123hello

           function sum(a,b){
              console.log(a+b)
            }
           sum(true,false)             //控制台输出:1

       *  调用函数时，解析器也不会检查实参的数量
            多余实参不会被赋值
          如果实参的数量少于形参的数量，则没有对应实参的形参将时undefined
          function sum(a,b){
              console.log(a+b)
            }
           sum(1,2,true,false)             //控制台结果是3
      */
    </script>
    <script id="函数的返回值">
      /*  首先 我们先创建一个函数，用来计算三个数的和
            function sum(a , b , c){
              console.log(a + b + c)
            }
            //调用函数
            sum(4,7,8)   //控制台结果19

            //算完的结果就给我输出出来了，你说这种东西它好不好啊？
            //这个19的值是不是我想输出的呢？不一定。结果算出来我可能想干别的去用。就像你去称体重，刚站秤上 旁边有一人看见了给你念出来了说他体重两百！
              那你是不希望他念出来啊？不用 我希望我称完这个体重 知道结果就行了。
              同理 我只需要一个结果，而不需要你替我来处理这个结果
              往往执行一个函数时，是需要将这个结果返回的，而不是输出。那问题来了 我们怎么将这个结果返回呢?

       *  可以使用return,来设置返回的值
            语法：
              return 值
              return //如果return后面不跟值，就相当于return undefined
            return后的值将会作为函数的执行结果返回，
              可以定义一个变量，来接收该结果

            function sum(a,b,c){
              var d = a + b + c
              return d
            }
            //调用函数
            //变量result的值就是函数的执行结果
            //函数返回什么result的值就是什么
            var result = sun(4,7,8)
            console.log("result = "+result)            //控制台结果是result=19

          在函数中return后面的语句都不会执行
            function sum(a,b,c){
            var d = a + b + c
            return d
            alery=t("hello")                           //控制台结果是result=19，alert没有执行。因为函数的结果在return这儿已经返回了，下面的它已经没有执行的必要了。
            }
            var result = sun(4,7,8)
            console.log("result = "+result)

          如果return语句后面不跟值，就相当于返回一个undefined
            function sum(a,b,c){
            var d = a + b + c
            return
            }
            var result = sun(4,7,8)
            console.log("result = "+result)          //控制台结果是result undefined

          如果函数中不写return，则也会返回undefined
            function sum(a,b,c){
            var d = a + b + c
            }
            var result = sun(4,7,8)
            console.log("result = "+result)          //控制台结果是result undefined

          return语句后可以跟任意类型的值
            function sum(a,b,c){
            var d = a + b + c
            return "hello"
            }
            var result = sun(4,7,8)
            console.log("result = "+result)          //控制台结果是result=hello
       *
      */
    </script>

    <script id="实参可以是任意值">
      /*
       *  //定义一个函数，判断一个数字是否是偶数，如果是返回true，否则返回false
          function isOu(num) {
            if (num % 2 == 0) {
              return true;
            } else {
              return false;
            }
          }
          var result = isOu(4);
          console.log("result = " + result);
          //这样写是可以的，但是不够优雅

          function isOu(num) {
            return num % 2 == 0                                     //num % 2 == 0这是一个式子，它是有结果的，如果num % 2如果它有余数返回false，如果没有余数返回true
          }
          var result = isOu(4);
          console.log("result = " + result);




       *  //定义一个函数，可以根据半径计算一个圆的面积，并返回计算结果
          //圆面积的公式pai r方
          //3.14*r*r

          function mianji(r) {                                      //要计算圆的面积，得知道半径，所以需要传一个r
            return 3.14 * r * r;
          }
          result = mianji(10);
          console.log("result = " + result);

       *  //创建一个函数，可以在控制台中输出一个人的信息
              可以输出人的name age gender address

          function information(name, age, gender, address) {
              console.log(
                "我是" +
                  name +
                  ",今年我" +
                  age +
                  "岁了," +
                  "我是一个" +
                  gender +
                  "人" +
                  ",我住在" +
                  address
              );
            }
            information("孙悟空", "18", "男", "花果山");
            //控制台输出我是孙悟空,今年我18岁了,我是一个男人,我住在花果山
            //现在的参数有点多，假如我还想输出它的身高体重等一系列信息，我需要更多的参数。参数多容易乱。像这种参数多的写时一定要注意顺序问题
            //现在让我传4个参数，如果以后参数更多了可能让我传10个 20个...当我一个一个传它是很麻烦的，想想有什么更方便的方法
            //创建一个对象
            var obj = {
              name:"孙悟空"
              age:18
              gender:"男"
              address:"花果山"
            }
            //我这对象有4个属性，那我能不能把对象作为参数传进去？现在传肯定不行，现在的参数还是name age...不对
            //那我这对象能不能作为实参？
            实参可以是任意的数据类型，也可以是一个对象
              当我们的参数过多时，可以将参数封装到一个对象中，然后通过对象传递

            function information(o) {
              console.log(
                "我是" +
                  o.name +
                  ",今年我" +
                  o.age +
                  "岁了," +
                  "我是一个" +
                  o.gender +
                  "人" +
                  ",我住在" +
                  o.address
              );
            }
            var obj = {
              name: "孙悟空",
              age: 18,
              gender: "男",
              address: "花果山",
            };
            information(obj);
            //控制台输出我是孙悟空,今年我18岁了,我是一个男人,我住在花果山

       *  实参可以是一个对象，也可以是一个函数
          function fun(a){
            console.log("a = "+a)
          }
          fun(123)                 //控制台输出123

          function fun(a){
            console.log("a = "+a)
          }
          fun(information)         //information函数作为实参传给fun，那现在a等于谁？a = function information(o) {
                                                                                        console.log(
                                                                                          "我是" +
                                                                                            o.name +
                                                                                            ",今年我" +
                                                                                            o.age +
                                                                                            "岁了," +
                                                                                            "我是一个" +
                                                                                            o.gender +
                                                                                            "人" +
                                                                                            ",我住在" +
                                                                                            o.address
                                                                                        );
                                                                                      }
                                   //a等于function,function名叫information，换句话说现在a和information是一样的
                                   //甚至我还可以在里面调用
            function fun(a) {
              a(obj);              //fun(information);  等价于 information(obj);
            }
            fun(information);
            //控制台输出我是孙悟空,今年我18岁了,我是一个男人,我住在花果山

       *  mianji()
            调用函数
            相当于使用函数的返回值
          mianji 函数名
            函数对象
            相当于直接使用函数对象

          function fun(a){
          console.log("a = "+a)
          }
          fun(mianji(10))
          //控制台输出a = 314

          function fun(a){
          console.log("a = "+a)
          }
          fun(mianji)
          //控制台输出a = function mianji(r) {
                        //要计算圆的面积，得知道半径，所以需要传一个r
                        return 3.14 * r * r;
                      }

          普通对象可能像一个容器 像一个塑料袋，只能去装东西。
          而函数它是一个有功能的对象，它就像一个做冰淇淋的机器，除了具有普通对象的功能外，它可以生产拉冰淇淋。
            直接写mianji 相当于我把机器给别人了                                                    //函数对象本身
            而mianji()   我是在调用冰淇淋机 我在使用它，相当于把冰淇淋机拉出来的冰淇淋给别人        //函数的返回值
          所以注意 是想传函数对象本身还是想传它的返回值
      */
    </script>

    <script id="返回值的类型">
      /*
       *  //return和break有点像，我们来对比一下它们
          function fun() {
            alert("函数要执行了~~~");
            for (var i = 0; i < 5; i++) {
              if (i == 2) {
                //使用break可以退出当前的循环
                //break;                                      //控制台结果0 1
                //continue用于跳过当次循环
                //continue;                                   //控制台结果0 1 3 4
                //使用return可以结束整个函数
                return;                                       //控制台结果0 1，并且return一执行它后面所有语句都不执行
              }
              console.log(i);
            }
            alert("函数执行完了~~~");
          }
          fun();

       *  返回值可以是任意的数据类型
          function fun2(){
            return 10
          }
          var a = fun2()//让a等于fun2的返回值
          console.log("a = "+a)
          //控制台输出a = 10


       *  返回值也可以是一个对象
          function fun2(){
            var obj = {name:"沙和尚"}
            return obj
          }
          var a = fun2()//让a等于fun2的返回值
          console.log("a = "+a)
          //控制台输出a = [object Object]


          function fun2(){
            var obj = {name:"沙和尚"}
            return obj
          }
          var a = fun2()//让a等于fun2的返回值
          console.log("a = "+a.name)
          //控制台输出a = 沙和尚


          function fun2(){
            return {name:"沙和尚"}
          }
          var a = fun2()//让a等于fun2的返回值
          console.log("a = "+a.name)
          //控制台输出a = 沙和尚

       *  返回值也可以是一个函数
          function fun3() {
            //在函数内部再声明一个函数
            function fun4() {
              alert("我是fun4");
            }
            //将fun4函数对象作为返回值返回
            return fun4;
          }
          a = fun3();
          console.log("a = " + a);                       a()                                   fun3()();
          //控制台输出a = function fun4() {              //控制台输出我是fun4                   //控制台输出我是fun4
                        alert("我是fun4");
                      }

      */

    </script>

    <script id="立即执行函数">
      /*
       *  什么是立即执行函数呢？函数定义完后，立即执行，只能执行一次
          我们来写这么一个东西
            function(){
              alert("我是一个匿名函数~~~")
            }
          //函数没有名，像这种函数，语法是不允许的，因为它把这{}当成一个代码块了，然后前面的这个function()它不认识了，这样写完直接报错
          //那我用一个()来圈起来一个匿名函数来表示我这个匿名函数是一个整体，这回我再刷新，就不报错了
            (function(){
              alert("我是一个匿名函数~~~")
            })
          //那这种函数我要去调用怎么调？

       *  调用函数方法是:
          (
          function () {
              alert("我是一个匿名函数，因为没有名字，所以只能被调用一次");
          })(); //前面的括号是把匿名函数看成一个整体，后面的括号是为了调用该函数

          (function (a, b) {
            console.log("a = " + a);
            console.log("b = " + b);
          })(123, 456);
          //控制台输出:
                      a = 123
                      b = 456
      */

    </script>

    <script id="全局作用域">
      /*
       *  作用域
            作用域指一个变量的作用的范围
            举个例子:
                    function fun(){
                      var a = 123             //在函数内部声明一个变量a 它的值是123
                    }
                    fun()                     //调用函数
                    console.log(a)            //控制台输出报错
                    //也就是说我在函数外部不能看到函数里面的a，那就证明a的作用域就在函数里，在外面是看不见的，这就是作用域
            在JS中一共有两种作用域
              1.全局作用域
              2.函数作用域

       *  全局作用域
            直接编写在script标签中的JS代码，都在全局作用域
            全局作用域在页面打开时创建，在页面关闭时销毁
            在全局作用域中 有一个全局对象window
              它代表的是一个浏览器的窗口，它由浏览器创建 我们可以直接使用
              console.log(typeof window)
              //控制台输出:object
            在全局作用域中
              创建的变量都会作为window对象的属性保存
              var a = 10                      //创建一个变量 a a的值是10
              console.log(a)
              //控制台输出:10
              //a这个变量会作为window对象的属性保存，所以注意，虽然是一个变量，但这个变量实际上保存是保存到window对象里
              //所以既然是window对象的属性
              var a = 10                      //实际上是window.a
              console.log(window.a)
              //控制台输出:10

              创建的函数都会作为window对象的方法保存
              function fun(){
                console.log("我是fun函数")
              }
              fun()                           //实际上是window.fun()
              //控制台输出:我是fun函数
              alert("hello")                  //实际上是window.alert("hello")

       *  变量的声明提前
            //我们先看一下
              var a = 123
              console.log("a = "+a)
              //控制台输出: a = 123

              声明变量使用war关键字，不写var行不行呢？
              a = 123                                 也行，注意 不写var 就相当于window.a = 123
              console.log("a = "+a)
              //控制台输出: a = 123

       *  变量的声明提前
              console.log("a = "+a)
              var a = 123
              //控制台输出: a = undefined //值是undefined但这块儿却没报错!

              console.log("a = "+a)
              a = 123
              //控制台输出: 报错!
              那这是为什么呢？
            使用var关键字声明的变量，会在所有的代码之前被声明好(但是不会赋值)
              console.log("a = "+a)                 var a;                       //这个var a会在所有代码被执行之前执行，执行完声明一个变量a
              var a = 123                           console.log("a = "+a)        //然后输出
                                                    a = 123
            但是如果声明变量时不使用var关键字，则变量不会被声明提前

       *  函数的声明提前
            使用函数声明形式创建的函数function 函数名()，它会在所有代码执行之前就被创建，所以我们可以在函数声明前来调用函数
              fun();
              function fun() {             //虽然写在后面，但是代码在执行之前它的优先级高，解析器会优先解析它。不仅声明提前，它还把函数直接创建好
                console.log("我是函数声明");
              }
              控制台输出:我是函数声明
            使用函数表达式创建的函数不会被声明提前，所以不能在声明前调用
              fun2()
              var fun2 = function(){       //函数表达式，首先变量会提前声明，但注意此时仅仅是提前声明，没有赋值，所以fun2是undefined。所以不能在声明之前调用
                console.log("我是函数表达式");
              }
              控制台输出:报错!

       *  全局作用域中的变量都是全局变量，在页面的任意的部分都可以访问的到
      */
    </script>

    <script id="函数作用域">
      /*
       *  函数作用域
            调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁
            每调用一次函数就会创建一个新的函数作用域，它们之间是互相独立的
              function fun(){

              }
              fun()
              fun()
              fun()
              //以上三个函数作用域，他们之间是互相独立的

            在函数作用域中可以访问到全局作用域的变量
              //创建一个变量
              var a = 10;
              function fun() {
                console.log("a = " + a);
              }
              fun();
              //控制台输出: a = 10

            在全局作用域中无法访问到函数作用域的变量
              function fun() {
                var b = 20
              }
              fun();
              console.log("b = "+b)
              //控制台输出: 报错!
            //在局部可以访问到全局，在全局无法访问到局部

       *  当函数作用域中操作一个变量时，它会现在自身作用域中寻找，如果有就直接使用
            如果没有则向上一级作用域中寻找，直到找到全局作用域，
            如果全局作用域中依然没有找到，则会报错ReferenceError
              var a = 10
              function fun(){
                var a = ("我是函数中的变量a")
                console.log("a = "+a)          //两个a 一个全局变量a，一个函数作用域变量，我在函数里去访问a，它会访问谁呢？(它会现在自身作用域中寻找，如果有就直接使用，如果没有则向上一级作用域中寻找)
              }
              fun()
              console.log("a = "+a)
              //控制台输出:
                            a = 我是函数中的变量a
                            a = 10

       *  在函数中要访问全局变量可以使用window对象
              var a = 10;
              function fun() {
                var a = "我是函数中的变量a";
                function fun2() {
                  console.log("a = " + window.a);  //我想找全局变量的a，全局变量的a是window的属性，所以可以写成window.a。在函数作用域里想访问全局变量直接加window，不加window就近访问，加window全局
                }
                fun2();
              }
              fun();
              //控制台输出:
                          a = 10

       *  在函数作用域中也有声明提前的特性，
            使用var关键字声明的变量，会在函数中所有的代码执行之前被声明(但是不会赋值)
              function fun3() {                          function fun3() {
                console.log(a);                            var a;
                var a = 35;                                console.log(a);
              }                                            a = 35
              fun3();                                    }
              //控制台输出:                                fun3();
                           undefinde

            函数声明也会在函数中所有的代码执行之前执行
              function fun3(){
                fun4()
                function fun4(){
                  alert("我是函数声明")
                }
              }
              fun3()
              //控制台输出: 我是函数声明

       *  在函数中，不使用var声明的变量都会成为全局变量
              var c = 33;
              function fun5() {
                console.log("c = " + c); //先找局部的c，未找到，就找全局的c
                c = 10;                  //这个c是全局变，因为没有使用关键字var。和函数外的c是同一变量，等价于window.c= 10;
              }
              fun5();
              //在全局中输出c
              console.log("c = " + c);
              //控制台输出:
                          c = 33
                          c = 10

              var c = 33;
              function fun5() {
                d = 100                  //d因为没有使用关键字var，则会成为全局变量，等价于window.d= 100;
              }
              fun5();
              //在全局中输出c
              console.log("d = " + d);
              //控制台输出:
                          d = 100
       *  定义形参就相当于在函数作用域中声明了变量
              var e = 23
              function fun6(e){
                //所以我定形参e就相当于在声明了变量var e;
                alert(e) //它找函数作用域 有这个e，但是没有赋值，所以控制台输出undefined
              }
              fun6()
              //控制台输出:
                          undefined

      */

    </script>

    <script type="xxx" id="函数练习">
      // 判断一个数是不是素数
      //  是的话返回true
      //  不是的话返回false
      var n = Number(prompt("请输入一个数是不是素数:"));
      function isPrime(n) {
        for (var i = 2; i * i <= n; i++) {
          if (n % i == 0) {
            return false; //return 语句会终止函数的执行并返回函数的值。
          }
        }
        return true;
      }
      var result = isPrime(n);
      console.log(result);
    </script>

    <script type="xxx" id="函数练习">
      // 如果一个数与7有关就返回真，否则返回假
      //    (与7有关，是7的倍数或任意位上有7)
      var n = Number(prompt("请输入"));
      function qiao7(n) {
        if (n % 7 == 0) {
          return true; //但它不是7的倍数也不代表它就与7无关，因为还要考虑它各个位上是不是7
        }
        while (n > 0) {
          var digit = n % 10; //123 3   12 2
          if (digit == 7) {
            return true;
          }
          n = (n - digit) / 10; //123-3/10=12   12-2/10=1
        }
        return false;
      }
      console.log(qiao7(n));
    </script>

    <script type="xxx" id="函数练习">
      //给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。
      //丑数 就是只包含质因数 2、3 和/或 5 的正整数。
      //解题思路 怎样判断呢？
      //就拿这个n除以2 除以3 除以5，要是能除我就一直除 除到最后的话能把2、3、5这些数除完只剩1
      var isUgly = function(n) {
        while (n % 2 == 0){ //如果n % 2 == 0说明它可以除以2，n就等于n除以2。除一次是不够的，比如20。20/2=10，10还能再除以2，所以while循环。
            n = n / 2
        }
        while (n % 3 == 0) {
            n = n / 3
        }
        while (n % 5 == 0){
            n = n / 5
        }
        return n == 1 //最后它真的能够在上面的一直除来除去的过程中 把2、3、5的因子除完并且它真的是丑数的话，那么它只会剩1
    };
    </script>

    <script id="练习">
      var a = 123
      function fun(){
        alert(a)
      }
      fun()
      //此网页显示123


      var a = 123
      function fun(){
        alert(a)
        var a = 456
      }
      fun()
      alert(a)
      //变量提前声明，此网页显示undefined。点击确定此网页显示123


      var a = 123
      function fun(){
        alert(a)
        a = 456
      }
      fun()
      alert(a)
      //此网页显示123。点击确定此网页显示456

      var a = 123
      function fun(a){
        alert(a)
        a = 456
      }
      fun()
      alert(a)
      //此网页显示undefined。点击确定此网页显示123

      var a = 123
      function fun(a){
        alert(a)
        a = 456
      }
      fun(123)
      alert(a)
      //此网页显示123。点击确定此网页显示123
    </script>

    <script id="this">
      /*
       *  解析器(浏览器)在调用函数时 每次都会向函数内部传递进一个隐含的参数
          这个隐含的参数就是this(注意 这个东西浏览器每次都会传)
            function fun(a,b){
              console.log("a = "+a, "b = "+b)
            }
            fun(123,456)
            //控制台输出:a = 123 b = 456

            //那既然传了我们来看看有没有
            function fun(a,b){
              console.log(this)
            }
            fun(123,456)
            //控制台输出:全局对象window
            //那window你直接来个window不就完了，干嘛非得叫this啊？

       *  this指向的是一个对象
          这个对象我们称为函数执行的上下文对象//注意了 那是不是说这个对象一直都是window啊？不是。如果它一直都是window那就没有意义了
          根据函数 调用方式 的不同，this会指向不同的对象
            1.以函数的形式调用时，this永远都是window
            2.以方法的形式调用时，this就是调用方法的对象(说白了这个方法是谁调的 this就是谁)

                                                                                        如果一个函数作为一个对象的属性保存，
                                                                                        那么我们称这个函数是对象的方法
                                                                                        调用这个函数就是调用对象的方法(method)

            function fun(){
              console.log(this)
            }
            //fun()

            //创建一个对象
            var obj = {
              name: "孙悟空",
              sayName: fun, //我是把obj的一个属性设置成函数。那么现在obj.sayName()等于fun()
            };
            console.log(obj.sayName == fun);
            //控制台输出:true

            var obj = {
              name: "孙悟空",
              sayName: fun,
            };
            obj.sayName()
            //控制台输出:
                        Object
                          name: "老孙"
                          sayName: ƒ fun()

            //fun()和obj.sayName()调的是同一个函数，但结果却不同
            //fun()控制台输出:
                              window
            //obj.sayName()控制台输出:
                                      Object
                                        name: "孙悟空"
                                        sayName: ƒ fun() //也就是说我这儿打印的对象就是obj


       *  this 并不是固定不变的，根据调用方式不同发生变化
            var name = "全局的name属性"
            function fun(){
              console.log(this.name)
            }
            //fun()
            var obj = {
              name: "孙悟空",
              sayName: fun,
            };

          //以函数形式调用，this是window。所以我在这里面打印this.name就相当于window.name
            fun();
            //控制台输出:
                        全局的name属性

          //以方法的形式调用，this是调用方法的对象。对于这种方式来说，this就是obj。所以我打印this.name就相当于obj.name
            obj.sayName()
            //控制台输出:
                        孙悟空

      */
    </script>

    <script id="this补充">
      /*
       *  //创建一个name变量
          var name = "全局";
          //创建一个fun()函数
          function fun() {
            console.log(this.name);
          }
          //创建两个对象
          var obj = {
            name: "孙悟空",
            sayName: fun,
          };
          var obj2 = {
            name: "沙和尚",
            sayName: fun,
          };
          //我希望调用obj.sayName()时，可以输出obj的名字
          obj.sayName();
          obj2.sayName();
      */
    </script>

    <script id="使用工厂方法创建对象">
      /*
       *  //创建一个对象
            var obj = {
              name: "老孙",
              age: 18,
              gender: "男",
              sayName: function () {
                alert(this.name);
              },
            };
          //obj.sayName();
          //此网页显示: 老孙。
          //现在创建一个不过瘾我希望再创建几个
            var obj2 = {
              name: "老朱",
              age: 28,
              gender: "男",
              sayName: function () {
                alert(this.name);
              },
            };
            var obj3 = {
              name: "老沙",
              age: 38,
              gender: "男",
              sayName: function () {
                alert(this.name);
              },
            };
            obj.sayName();
          //此网页显示: 老孙
            obj2.sayName();
          //此网页显示: 老朱
            obj3.sayName();
          //此网页显示: 老沙
          但是我发现创建这3个对象有点笨，复制粘贴这种创建方式有点麻烦！
          假如我要创建是个对象我得复制十次，不方便大批量的生产对象
          我希望创建对象的方式能简单一点儿，换句话说我希望能优雅一点儿，至少这件事儿干起来不要像这样这么笨
          我们发现在创建对象的过程中有大量的重复性的代码！那我能不能把重复性的东西提取出来呢？
          提取到一个函数里，一个方法里，然后在我调的时候 我直接调函数就行了

       *  使用工厂方法创建对象
          //工厂 什么叫工厂？可以批量生产。你给我原料 我给你生产产品
                                          而我们这个，你给我属性，我给你生产对象。可以大批量的生产对象，想要多少要多少

          //创建一个对象
            var obj = {
              name:"老孙"
              age:18
              gender:"男"
              sayname:function(){
                alert(this.name)
              }
            }
          //使用工厂方法创建对象
            //通过该方法可以大批量创建对象
            function createPerson(){
              //创建一个新的对象
              var obj = new Object()     //和上面的对象不是一个，这个在函数里创建的对象是局部的，上面的是全局的

              //向对象中添加属性
              obj.name = "老孙"
              obj.age = 18
              obj.gender = "男"
              obj.sayName = function(){
                alert(this.name)
              }
              //将新的对象返回
              return obj
            }
            var obj2 = createPerson()     //以后我们再想创建对象，直接调createPerson就行了
          //console.log(obj2)
          //控制台输出:
                        Object
                          age: 18
                          gender: "男"
                          name: "老孙"
                          sayName: ƒ ()
            var obj3 = createPerson()
            var obj4 = createPerson()
            console.log(obj2)
            console.log(obj3)
            console.log(obj4)
          //控制台输出:
                        Object
                          age: 18
                          gender: "男"
                          name: "老孙"
                          sayName: ƒ ()
                        Object
                          age: 18
                          gender: "男"
                          name: "老孙"
                          sayName: ƒ ()
                        Object
                          age: 18
                          gender: "男"
                          name: "老孙"
                          sayName: ƒ ()
          但是这块儿不对劲儿了，只能造老孙？我想造老朱老沙造不出来啊，为什么？name，age，gender都写死了
          所以注意，这块儿不能写死了。不能写死怎么办？
          我是不得从外边进来啊？
          我想创建老孙 我可以传一个我要建老孙。我想创建老朱，我可以传一个我要建老朱
          所以name，age，gender都应该是从外边传进来的
          从外边怎么传？参数传

            function createPerson(name, age, gender) {
              var obj = new Object();   //所以我这块儿定义三个参数
              obj.name = name;          //那现在呢我这就不等于老孙了，等于name
              obj.age = age;            //那现在呢我这就不等于18了，等于age
              obj.gender = gender;      //那现在呢我这就不等于男了，等于gender
              obj.sayName = function () {
                alert(this.name);
              };
              return obj;
            }
            var obj2 = createPerson("老孙", 18, "男");
            var obj3 = createPerson("老朱", 28, "男");
            var obj4 = createPerson("老沙", 38, "男");
            console.log(obj2);
            console.log(obj3);
            console.log(obj4);
            obj2.sayName()
            obj3.sayName()
            obj4.sayName()
          这种方法更方便，我只需要传三个属性到参数中，其他的都在函数中封装起来了。这种方式更方便我们去批量的创建对象，相对来说比较简单一点

      */

    </script>

    <script id="数组的基本用法">
      /*
       *  数组就是一系列数字，有序的集合
          一个数里面可以存多个东西
          存数：
            var a = []                   创建空数组
            var a = [1,2,3,4,5]          创建非空数组
            a
            (5) 1,2,3,4,5

            它是有序集合，所以这些数在数组里面是有顺序的，有点像数列
            数组里面的元素是从0开始编号的，所以这个1它是第0项，我们称它下标为0或者索引是0。

            那我怎么拿到它的第一项，第二项，第三项呢？
            a[里面写上下标]
            例如a[2]，表示数组中的第3项 已经拿到3了

            a[2]=8,那么a这个数组的第二项由3变成8了
            a
            (5) 1,2,8,4,5
            a[4]=9,那么a这个数组的第二项由3变成8了
            a
            (5) 1,2,8,4,9

            总之a[4]这是个表达式，所以哪里可以写表达式，哪里就可以写它。哪里可以写它，哪里就可以写表达式。哪里是表达式，哪里就可以换成它。
            比如说a[4]++
            9
            a
            (5) 1,2,8,4,10

          a.length 得到数组的长度
          5 但是长度为5的时候最大下标最大索引是4，因为它是从0开始编号的

          a.push(2) 往数组的末尾添加一项
          6 push返回6什么意思呢？ 是push完以后 这个数组有多长。同时它把这个2放到了数组的末尾
          a
          (6) 1,2,8,4,10,2
          a.push(3)
          7
          a
          (7) 1,2,8,4,10,2,3
          a.push(0,9,1,8)
          11
          a
          (11) 1,2,8,4,10,2,3,0,9,1,8

          a.unshift(8) 从数组的前面增加一项
          (12) 8,1,2,8,4,10,2,3,0,9,1,8
          a.unshift(1,2,3)
          (15) 1,2,3,8,1,2,8,4,10,2,3,0,9,1,8

          a.pop() 从数组的末尾删除一项，并且pop会把删除的最后一项返回给你。pop的时候一次只能pop一个，不接收参数，传参没有任何效果
          8
          a
          (14) 1,2,3,8,1,2,8,4,10,2,3,0,9,1

          a.shift() 从数组的前面删除一项
          1
          a.shift()
          2
          a.shift()
          3
          a.shift()
          8
          a.shift()
          1
          a.shift()
          2
          a
          (8) 8,4,10,2,3,0,9,1

          总结：
               unshift 数组前面增加
               shift  数组前面删除
               push  数组后面增加
               pop  数组后面删除

               素组是值的有序集合
               var a = [] 创建空数组
               var a = [1,2,3,4] 创建非空数组
               console.log(a[0]) 取出数组第一项，即下标/索引为0的项
               console.log(a[1]) 取出数组第二项，即下标/索引为1的项
               a[2]=888 给素组下标2号元素赋值
               a.length 直接得到数组长度
               a.push(5) 向数组末尾增加元素，并返回新的长度
               a.push(5,6) 可以向素组末尾一次性增加多个元素，同样会返回新的长度
               a.pop() 删除并返回数组最后一项，一次只能删除一项
               a.unshift(9) 向数组前面增加元素，并返回新的长度
               a.unshift(10,11) 可以向数组前面一次性增加多个元素，同样会返回新的长度
               a.shift() 删除并返回数组第一项，一次只能删除一项

          a
          (8) 8,4,10,2,3,0,9,1
          a[3]是2
          a[a[3]] a[2] 10

          i=2
          a[i*i] 即4的下标 第5项 3

          a=[Nan,true,['a','b','c'],5,5]
          那么我想去出c
          a[2][2]

          练习：
          //输入一个n 再输入n个数，对这n个数倒叙输出
          var n = Number(prompt())
          var a = []//首先创建一个数组
          for(var i =0 ; i < n; i++){
            var number = Number(prompt())
            a.push(number)//输入完这n个数我就把这些数添加到数组里面去
          }
          for(var i = a.length - 1 ; i >= 0 ; i--){ //倒叙循环 i下标2，1，0
            console.log(a[i])
          }
      /*
    </script>

    <script id="字符串的操作">
      /*
       *  其实字符串和数组还是比较像的，数组里面我每一项可以改的，但字符串不能改
          例如:
            s= 'slkgjkgs'
            //同样可以通过s下标读到它的第几项，比如我要读到它的s
            s[1]
            'l'  //但求值结果依然是字符串

            //那我能不能把s改成大写的？这是不能的，改不了，但它也不会报错
            //我非想改怎么办？我可以由原来的构造成一个新的

          s
          s= 'slkgjkgs'
          它除了中括号以外，还可以用s.charAt(2) //字符at第二下标
          'k'

          s
          s= 'slkgjkgs'
          s.charCodeAt(2)//第二位上的字符的code（ascii码编号）
          111

          s
          s= 'slkgjkgs'
          s.indexOf('kg') //找kg的下标在哪儿 那就看起始字符第几个
          6

          s
          s = '25'
          s.padStart(5) //我需要这让这个字符有多宽，然后我需要补什么字符如果不填默认就是用空格
          '   25'
          s.padStart(5,'0') //也可以补0
          '00025'
          s.padStart(5,'0-')//补0-，那就补0-0- 前面差多少 差3个，那这只有两个 重读一次就超过三个了
          '0-025'
      */
    </script>

    <script id="整数在计算机中的表示">
      /*
       *  总结一下自己理解的知识点：
          1.原码、反码、补码是由8位二进制定点数组成，符号位位于最高位，且0代表正数，1代表负数。
          2.正数的原码、反码和补码全部相同。
          3.①负数的原码符号位为1
            ②负数的反码是除符号位外全部取反。
              例如：若已知负数 绝对值原码为10010111，求反码。
                        答：1（符号位不变）1101000
            ③已知原码求补码，先取反再加1。
              例如：若已知负数绝对值原码为10010111，求补码。
              答：先取反，首位不变，其余取反得11101000。
              然后+1，得11101001。
            ④若已知补码，求原码也是取反+1。
              例如：若已知负数补码为11101001，求补码。
              答：先取反，首位不变，其余取反得10010110。
              后+1，得10010111。
      */

    </script>

    <script id="箭头函数">
      /*
       *  ES6的箭头函数 =>
          语法
            let 函数 = ()=> 555
            console.log(函数())
            等同于
            function 函数(){
              return 555
            }
            console.log(函数())

            如果返回的是一个对象
            let 函数 = _n=>({id:_n, name:'请求三连操作'})       //加上()因为在js解析引擎里，{}被认为是代码块，不加()会被报错
            console.log(函数('点赞、收藏、投币'))

          在箭头函数中，this指向是它所在函数的父级函数的作用域，而不是它所在的函数




      */

    </script>



  <!-- </head> -->
  <body>
    <!-- 可以将js代码编写到标签的onclick属性中
    虽然可以写在标签的属性中，但是它们属于结构与行为偶合，不方便我们维护-->
      <!-- <button onclick="alert('讨厌，你点我干嘛~~');">点我一下</button> -->
    <!-- 当我们点击按钮时，js代码才会执行 -->

    <!-- 可以将js代码写在超链接href属性中 -->
      <!-- <a href="javascript:alert('让你点你就点~');">你也点我一下</a> -->
    <!-- 当我们点击超链接时，会执行我们的js代码 -->
      <!-- <a href="javascript:;">你也点我一下</a> -->
    <!-- 我们希望超链接点完没有反应，通过js处理一些功能 -->
  </body>
</html>
